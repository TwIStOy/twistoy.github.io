<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>核桃的炼金工坊</title>
        <link>https://twistoy.com</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://twistoy.com/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Mon, 12 Sep 2022 00:00:00 +0000</lastBuildDate>
        <item>
            <title>推し、燃ゆ</title>
            <pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/oshi-moyu/</link>
            <guid>https://twistoy.com/posts/oshi-moyu/</guid>
            <description>&lt;p&gt;（全部的内容都是零碎的，没头没尾的，写给自己的，当下的想法，没想是个文章，就这样吧）&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅仅是起床，床单就会皱起来；仅仅是活着，人也会皱起来。和其他人说话需要绷紧理论上的肉，身体脏了需要泡澡，指甲长长了需要剪掉。最低限度的活着，也并非绞尽力气就一定能做到。我总是在完成最低限度之前，意识和身体就断联了。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;“推し”是“押す”的名词形式，是偶像发展起来才出的新用法。指“本命”，“为偶像应援”。&lt;&#x2F;p&gt;
&lt;p&gt;“燃ゆ”是“燃える”的古语形式，有“焚烧”、“死亡”的意思。&lt;&#x2F;p&gt;
&lt;p&gt;整部小说细碎的情节，只能让我在情感上感受到前后段的一点点粘连。从高中退学、不和睦的家庭、失去的经济来源构成了在偶像出事之后的破烂生活。她大抵是努力过的吧。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;啊，是彼德·潘。毫无疑问，他就是那天从我头顶飞过的男孩。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;所以是什么让她炽热的沉浸在“推し”这件事情上的呢。是那天在头顶飞过的男孩，是在这个过程中才能感觉到真实存在的自己吧。也应该是那句，“才不想成为大人”的共鸣。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;怀抱相同烦恼的人影，凭依他的身体站在了眼前。我与他相连，与他对面的众人相连。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;书里的旁人会质问&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“年轻倒是没问题，但必须面对现实里的男人啊，否则很容易误入歧途。”&lt;br &#x2F;&gt;
“就是很那个啊，一本正经，小明这个人。”阿东抱着双臂望着我，唐突地评价起来。阿胜一听，立刻
不满的帮腔：“就是说啊。”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;成年人的傲慢在这一刻，就只要这一句，就猛的朝我扑过来。他大抵只是想要一杯浓点的酒吧，在没被满足之后用这样的方式发泄着他的不快。他们应该是认为，偶像和饭的关系是畸形的？不和他们一样的？不能理解的？&lt;&#x2F;p&gt;
&lt;p&gt;其实在里面，偶像是逃避。是明里在痛苦、在软弱、在不知所措的时候逃避的对象。要不怎么会被一句“才不想成为大人”击中呢。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;我看了他的演唱会，看了他的电影，看了他的综艺。虽然声音和体型都不同了，但眼瞳深处不经意间流露出的锐利仍然与年幼的他如出一辙。那样的眼神，会让我也不由自主地想怒视些什么。既不正面也不负面的巨大能量从身体深处喷涌而出，提醒我活着这件事。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;偶像是逃避的港湾，后来也变成了她的脊梁。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;是她抱在怀里的衣物对我造成了无法再逃避的伤害。我堆放在房间里的大量档案、写真、CD，那些我用尽全力收集来的东西，都不如一件衬衫、一双袜子更能真切地描绘一个人的现在。偶像已经退圈，他的将来会有其他人在身旁注视着。这才是我要面对的现实。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;乌鸦在啼叫。我环视着整个房间，光从回廊、窗户投射进来，将房间照的亮亮的。不仅是中心，全部的一切都会成为我活着的结果。骨头是我，血肉也是我。我回想起抛出棉签盒之前的场景。一直忘记收的杯子、残留着汤汁的盖饭、遥控器。视线扫过，最终，我还是选择收拾起来最轻松的棉签盒。想笑的冲动像气泡一样涌了上来，扑哧一声，又消失了。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;可最终生活还是要继续的，一片狼藉的生活还是要继续的。在所有的东西里，选了一个最容易的棉签盒用力的扔出去，最终也只能自己捡回来。然后收拾好屋子里的长了白色霉菌的饭团、空可乐瓶。也捡起来了自己狼藉个生活，既然不适合两足行走，那就趴在地上前进吧。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Customization Point Object</title>
            <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/cpo/</link>
            <guid>https://twistoy.com/posts/cpo/</guid>
            <description>&lt;h1 id=&quot;jie-jue-shi-yao-wen-ti&quot;&gt;解决什么问题？&lt;&#x2F;h1&gt;
&lt;p&gt;标题是要聊一下 C++20 带来的一些新的很有意思的新机制，或者说是新轮子。
用来解决库函数或者一些通用函数定制用户类型的行为的抽象。
比如，我现在要实现一个通用的算法：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void foo(T&amp;amp; vec);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我可能需要我的参数 &lt;code&gt;vec&lt;&#x2F;code&gt; 的类型 &lt;code&gt;T&lt;&#x2F;code&gt;。可以拿到他的两个对应迭代器和大小。（这里只是举个例子）
在这个时候，就是我的通用函数需要定制用户类型的行为。或者说，需要用户的类型提供我需要的能力。
对于这样的每一个对用户能力的要求，被称为一个 &lt;strong&gt;定制点&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;xian-zai-du-you-na-xie-fang-an&quot;&gt;现在都有哪些方案？&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;ji-cheng&quot;&gt;继承&lt;&#x2F;h2&gt;
&lt;p&gt;第一个办法显然是继承嘛，考虑这个例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class ConnectionBase {
  void on_buffer_received(std::span&amp;lt;char&amp;gt; buffer) {
    if (handle_buffer(buffer)) {
      &amp;#x2F;&amp;#x2F; ...
    }
  }

 protected:
  virtual bool handle_buffer(std::span&amp;lt;char&amp;gt; buffer) = 0;
};

class TlsConnection : public ConnectionBase {
 protected:
  bool handle_buffer(std::span&amp;lt;char&amp;gt; buffer) {
    &amp;#x2F;&amp;#x2F; ssl...
  }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;基类的纯虚函数 &lt;code&gt;ConnectionBase::handle_buffer(std::span&amp;lt;char&amp;gt; buffer)&lt;&#x2F;code&gt; 就是一个&lt;strong&gt;定制点&lt;&#x2F;strong&gt;。它在这里需要用户类型，也就是它的子类定义如何处理收到的 buffer 的行为。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crtp-curiously-recurring-template-pattern&quot;&gt;CRTP（Curiously Recurring Template Pattern）&lt;&#x2F;h2&gt;
&lt;p&gt;还是考虑上面那个例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename D&amp;gt;
class ConnectionBase {
  void on_buffer_received(std::span&amp;lt;char&amp;gt; buffer) {
    if (static_cast&amp;lt;D*&amp;gt;(this)-&amp;gt;handle_buffer(buffer)) {
      &amp;#x2F;&amp;#x2F; ...
    }
  }
};

class TlsConnection : public ConnectionBase&amp;lt;TlsConnection&amp;gt; {
  bool handle_buffer(std::span&amp;lt;char&amp;gt; buffer) {
    &amp;#x2F;&amp;#x2F; ssl...
  }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样基类可以直接访问子类的功能和实现，而且绕过了依赖虚表实现的多态调用有更好的性能。
缺点是在这样的情况下，&lt;strong&gt;定制点&lt;&#x2F;strong&gt;变的非常不明显，他可以不依靠任何的在基类中的声明来表达子类需要实现哪些&lt;strong&gt;定制点&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;adl-argument-dependent-lookup&quot;&gt;ADL（Argument-Dependent Lookup）&lt;&#x2F;h2&gt;
&lt;p&gt;依旧是上面那个例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;namespace tls {
  class TlsConnection {};

  bool handle_buffer(TlsConnection* conn, std::span&amp;lt;char&amp;gt; buffer); &amp;#x2F;&amp;#x2F; #1
}

namespace tcp {
  class TcpConnection {};

  bool handle_buffer(TcpConnection* conn, std::span&amp;lt;char&amp;gt; buffer); &amp;#x2F;&amp;#x2F; #2
}

tls::TlsConnection* tls;
tcp::TcpConnection* tcp;

handle_buffer(tls);  &amp;#x2F;&amp;#x2F; #1
handle_buffer(tcp);  &amp;#x2F;&amp;#x2F; #2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这种方案下，通过在对应参数的 &lt;code&gt;namespace&lt;&#x2F;code&gt; 来实现对应的定制功能，然后通过 &lt;code&gt;ADL&lt;&#x2F;code&gt; 来找到正确的实现。
在这样的方案下带来的一个问题就是，对于这个 &lt;code&gt;handle_buffer&lt;&#x2F;code&gt;，我们使用带 &lt;code&gt;namespace&lt;&#x2F;code&gt; 和不带 &lt;code&gt;namespace&lt;&#x2F;code&gt; 的版本可能会带来不一样的结果。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;xin-de-fang-an-shi-shi-yao-yang-de&quot;&gt;新的方案是什么样的？&lt;&#x2F;h1&gt;
&lt;p&gt;在 C++20 里，其实 ranges 也面临了类似的问题，需要兼容各种类型的容器就要为每个类型的容器定制对应的功能。ranges 给出的方案就是 CPO，customization point object。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A customization point object is a function object with a literal class type that interacts with program-defined types while enforcing semantic requirements on that interaction.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;CPO 有很好的泛型的兼容性，而且也可以弥补上面 ADL 所提到的问题。
考虑一个取一个任意类型容器的 &lt;code&gt;begin iterator&lt;&#x2F;code&gt; 的问题：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;namespace _Begin {
  class _Cpo {
    enum class _St { _None, _Array, _Member, _Non_member };

    template &amp;lt;class _Ty&amp;gt;
    static _CONSTEVAL _Choice_t&amp;lt;_St&amp;gt; _Choose() noexcept {
      if constexpr (is_array_v&amp;lt;remove_reference_t&amp;lt;_Ty&amp;gt;&amp;gt;) {
        return {_St::_Array, true};
      } else if constexpr (_Has_member&amp;lt;_Ty&amp;gt;) {
        return {_St::_Member, noexcept(_Fake_decay_copy(_STD declval&amp;lt;_Ty&amp;gt;().begin()))};
      } else if constexpr (_Has_ADL&amp;lt;_Ty&amp;gt;) {
        return {_St::_Non_member, noexcept(_Fake_decay_copy(begin(_STD declval&amp;lt;_Ty&amp;gt;())))};
      } else {
        return {_St::_None};
      }
    }

    template &amp;lt;class _Ty&amp;gt;
    static constexpr _Choice_t&amp;lt;_St&amp;gt; _Choice = _Choose&amp;lt;_Ty&amp;gt;();

   public:
     template &amp;lt;_Should_range_access _Ty&amp;gt;
       requires (_Choice&amp;lt;_Ty&amp;amp;&amp;gt;._Strategy != _St::_None)
      _NODISCARD constexpr auto operator()(_Ty&amp;amp;&amp;amp; _Val) const {
          constexpr _St _Strat = _Choice&amp;lt;_Ty&amp;amp;&amp;gt;._Strategy;
          if constexpr (_Strat == _St::_Array) {
            return _Val;
          } else if constexpr (_Strat == _St::_Member) {
            return _Val.begin();  &amp;#x2F;&amp;#x2F; #1: via member function
          } else if constexpr (_Strat == _St::_Non_member) {
            return begin(_Val);   &amp;#x2F;&amp;#x2F; #2: via ADL
          } else {
            static_assert(_Always_false&amp;lt;_Ty&amp;gt;, &amp;quot;Should be unreachable&amp;quot;);
          }
        }
  };
}

inline namespace _Cpos {
  inline constexpr _Begin::_Cpo begin;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个是 ranges 库里面的 &lt;code&gt;begin&lt;&#x2F;code&gt; 的实现，我只留下了为了说明问题的关键的部分。在这个实现里，用 &lt;code&gt;if constexpr&lt;&#x2F;code&gt; 处理了类型选择的大部分的逻辑。对于对一个容器类型求 &lt;code&gt;begin&lt;&#x2F;code&gt; 的操作被分成了三种情况，数组、成员函数、非成员函数。数组是 builtin 的类型就不聊了嘛；成员函数的调用类似上面的 CRTP 的用法，因为通过模板是明确拿到当前容器的类型的，可以直接调用对应自定义类型的成员；非成员函数的调用因为是直接用的 &lt;code&gt;begin&lt;&#x2F;code&gt; 这个名字，所以这里使用了上面的 ADL 的方式来找到对应容器自定义类型正确的处理函数。&lt;&#x2F;p&gt;
&lt;p&gt;为什么是一个 function object 而不是一个模板函数，是因为 function object 在这个情况下是不会被应用 ADL 的，也就是说不会被 ADL 找到的，避免了在 &lt;code&gt;#2&lt;&#x2F;code&gt; 那个地方的 ADL 递归调用的问题。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;references:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;eel.is&#x2F;c++draft&#x2F;customization.point.object#def:customization_point_object&quot;&gt;C++ Draft: customization point object&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;ranges&quot;&gt;Cppreference: ranges&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;brevzin.github.io&#x2F;c++&#x2F;2020&#x2F;12&#x2F;19&#x2F;cpo-niebloid&#x2F;&quot;&gt;Niebloids and Customization Point Objects&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>2020 总结</title>
            <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/2020-zong-jie/</link>
            <guid>https://twistoy.com/posts/2020-zong-jie/</guid>
            <description>&lt;h2 id=&quot;0x01&quot;&gt;0x01&lt;&#x2F;h2&gt;
&lt;p&gt;平时其实都没有写类似年终总结这类东西的习惯的，但是今年就想了想，还是想搞点什么东西。
或者是记下来我这个和平时也没啥区别的一年？&lt;br &#x2F;&gt;
不过有一说一，我这去年的总结来的还有点晚？hhh&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;0x02&quot;&gt;0x02&lt;&#x2F;h2&gt;
&lt;p&gt;本质上今年在生活上毫无变化，还是工作上班，回家游戏。&lt;&#x2F;p&gt;
&lt;p&gt;疫情还是带了我点什么的，至少让我在家里多呆了好久好久的时间。也算让我体验了在家
呆很久很久的感觉？讲道理，家里桌子椅子还有电脑都不舒服 TAT。都没法快乐的打游戏了。
回上海之后的隔离才是最开心的，还能在家里摸鱼。不过在家里的工作效率还是很高的，
毕竟在写东西的时候，是没人打扰的。仔细算下来，还比在办公室高一点呢！（而且摸鱼
的时间可确实是变多了哦）&lt;&#x2F;p&gt;
&lt;p&gt;疫情还让我变的更宅了？长久不说话，好像也让我更自闭了？&lt;&#x2F;p&gt;
&lt;p&gt;下半年的时候重新捡起了 WOW，现在回过头来看看，这个游戏本质上还是好玩的。至少比
现在的很多其他 MMORPG 要好玩很多。&lt;&#x2F;p&gt;
&lt;p&gt;12 月的时候，期待了很久的赛博朋克也发布了。但是我好像晕 3D… TAT！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;0x03&quot;&gt;0x03&lt;&#x2F;h2&gt;
&lt;p&gt;要说工作上有啥不一样的，大概就是今年我们公司上市了？
不过反正我期权也不多啦，就也就赚一点？&lt;&#x2F;p&gt;
&lt;p&gt;其他工作上好像没啥特别有意思的内容，不过今年自己的成长还可以？自我感觉吧。&lt;&#x2F;p&gt;
&lt;p&gt;今年我一定一定要推荐的书是：&lt;em&gt;A Philosophy of software design&lt;&#x2F;em&gt;。这个对我现在
组织代码，修 bug 和新 feature 开发时候都很有帮助。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;0x04&quot;&gt;0x04&lt;&#x2F;h2&gt;
&lt;p&gt;那先这样？第一次写这种东西… 还不太习惯…&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>搞了个 C++ 构建系统</title>
            <pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/cpp-build-system/</link>
            <guid>https://twistoy.com/posts/cpp-build-system/</guid>
            <description>&lt;p&gt;我平时的工作内容是开发在服务端上运行的网络程序，主要语言是 C++，并且几乎全部跑在统一的机器环境上。所以我们一直以来都在使用一套简单从 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;chen3feng&#x2F;blade-build&quot;&gt;blade-build&lt;&#x2F;a&gt; 魔改来的编译系统。这个系统的本质是一个 &lt;code&gt;Unix Makefile&lt;&#x2F;code&gt; 的生成器，这个生成器使用 &lt;code&gt;Python2&lt;&#x2F;code&gt; 编写，代码有点难以维护。（毕竟使用动态语言的东西就是这样，出活还是很快的，但是时间一长了，代码就变的很难维护。因为后来的人，很难完全理解其中每个变量的类型，这对于我这种长期写静态强类型语言的人来说，是很痛苦的。）&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;在这样的基础上，我就萌生了把这套系统推倒重来的想法，这次我想用一个大家都熟悉，并且一定会写的语言来完成，它还一定是强类型的。在这几个条件下面，我超爱的 &lt;code&gt;Rust&lt;&#x2F;code&gt; 就被我排除在外了，因为好像我们周围会写的人也不是很多。再加上人家 &lt;code&gt;cmake&lt;&#x2F;code&gt; 也是用 C++ 来写的，我一想，我应该也比人家不差啥。再说，我还可以去 &lt;code&gt;cmake&lt;&#x2F;code&gt; 里面去偷很多实现出来。就这么决定了，用 C++ 来实现这个新的构建系统。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;jk-build&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;jk-build&quot;&gt;JK-Build&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;首先就是名字了，为啥叫 &lt;code&gt;jk&lt;&#x2F;code&gt;，那肯定有很多不可爱的人有奇奇怪怪的想法了！我当时起这个名字的时候，完全是图这两个按键在键盘上位于很近的位置，并且由于我是个 &lt;code&gt;vim&lt;&#x2F;code&gt; 的用户，其实手也常年在这两个按键附近，他们真的很近，很方便，就随手用了这个名字。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;na-xian-zai-de-xi-tong-you-sha-wen-ti-ni&quot;&gt;那现在的系统有啥问题呢&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;首先就是，原罪之一就是 &lt;code&gt;Python&lt;&#x2F;code&gt;。这个系统生成 &lt;code&gt;Makefile&lt;&#x2F;code&gt; 的速度在有的时候，它实在是有点慢了。&lt;&#x2F;li&gt;
&lt;li&gt;如果 &lt;code&gt;BUILD&lt;&#x2F;code&gt; 文件有改动了，它需要自己手动运行命令来重新生成。&lt;&#x2F;li&gt;
&lt;li&gt;对于 lint 来说，它的规则是尝试 &lt;code&gt;lint&lt;&#x2F;code&gt; 所有文件的，但是其实有很多文件是写出来放在那里，可以只搞了一半的（我就经常这样）。在这种时候我的代码是没法通过编译的，更不可能过 lint 了。&lt;&#x2F;li&gt;
&lt;li&gt;没有进度条。看看人家 &lt;code&gt;cmake&lt;&#x2F;code&gt;，还有个进度显示呢。这不就决定了我在编译的时候，是去喝杯咖啡，还是去拿个可乐嘛！&lt;&#x2F;li&gt;
&lt;li&gt;维护困难。&lt;code&gt;Python&lt;&#x2F;code&gt; 的代码有点难以维护，反正我在改的时候，是全靠着 &lt;code&gt;print&lt;&#x2F;code&gt;，到运行的时候观察每个变量到底是什么类型来 &lt;code&gt;debug&lt;&#x2F;code&gt; 的。&lt;&#x2F;li&gt;
&lt;li&gt;对于 &lt;code&gt;clang-base&lt;&#x2F;code&gt; 的工具，没有过匹配。大部分的，C++ 的代码检查和补全工具，其实都是建立在 &lt;code&gt;clang&lt;&#x2F;code&gt; 之上的，而 &lt;code&gt;clang&lt;&#x2F;code&gt; 会需要 compile database 来找到每个文件应该如何被编译，然后才能有 AST 或者其他的补全、提示什么的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;na-he-yi-qian-you-shi-yao-bu-tong-ni&quot;&gt;那和以前有什么不同呢&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;build-wen-jian-he-targets&quot;&gt;&lt;code&gt;BUILD&lt;&#x2F;code&gt; 文件和 &lt;code&gt;targets&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;从 &lt;code&gt;BUILD&lt;&#x2F;code&gt; 文件来看，是没什么不同的：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BUILD&lt;&#x2F;code&gt; 文件依旧是 &lt;code&gt;Python&lt;&#x2F;code&gt; 的语法。&lt;&#x2F;li&gt;
&lt;li&gt;所有的目标构建依旧是一些 &lt;code&gt;Python&lt;&#x2F;code&gt; 的函数。&lt;&#x2F;li&gt;
&lt;li&gt;暂时来说，可用的构建目标类型也没有增加。（毕竟完全兼容旧系统就有很多的工作了）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;新的系统，第一个目标就是完全兼容旧的所有已有的 &lt;code&gt;BUILD&lt;&#x2F;code&gt; 文件。毕竟，迁移的工作难度小了，新的系统才容易被大家接受。所以，所有的 &lt;code&gt;BUILD&lt;&#x2F;code&gt; 文件还依旧会是以前那样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;cc_library(name = &amp;quot;base&amp;quot;,
           cppflags = [ &amp;quot;-Ilibrary&amp;quot;, ],
           srcs = [ &amp;quot;*.cpp&amp;quot; ],
           excludes = [ &amp;quot;*_test.cpp&amp;quot; ],
           ldflags = [ &amp;quot;-ldl&amp;quot; ],
           deps = [
                    &amp;quot;&amp;#x2F;&amp;#x2F;library&amp;#x2F;logging&amp;#x2F;BUILD:logging&amp;quot;,
                    &amp;quot;&amp;#x2F;&amp;#x2F;library&amp;#x2F;memory&amp;#x2F;BUILD:memory&amp;quot;,
                    &amp;quot;:clock&amp;quot;,
                  ],
           )
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是从可用的参数和意义上来说，还是有很多不同的。比如，构建目标 &lt;code&gt;cc_library&lt;&#x2F;code&gt; 现在有个参数叫 &lt;code&gt;cppflags&lt;&#x2F;code&gt;，现在我们就面临着这个参数的值没法继承的问题。往往如果在一个 target 里写了一个 &lt;code&gt;-Ixxxx&lt;&#x2F;code&gt; 的参数，在依赖它的 target 里面还是不可避免的要写上。所以在新的系统中，给 &lt;code&gt;cc_library&lt;&#x2F;code&gt; 以及它的所有派生目标都加入了可以继承的，&lt;code&gt;includes&lt;&#x2F;code&gt; 和 &lt;code&gt;defines&lt;&#x2F;code&gt; 参数，用来传递信息给依赖这个目标的目标。&lt;&#x2F;p&gt;
&lt;p&gt;对于这部分的变化，就去文档上看就好啦。（虽然现在还没有）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bian-yi-jin-du&quot;&gt;编译进度&lt;&#x2F;h3&gt;
&lt;p&gt;还有进度条的加入。新的构建系统，在编译的时候，会有一个和 &lt;code&gt;cmake&lt;&#x2F;code&gt; 一样的计数进度的显示。这个地方 &lt;code&gt;cmake&lt;&#x2F;code&gt; 是通过统计一个目录下的文件个数来实现的，非常巧妙。具体的实现是，在一个编译命令的提示信息显示的同时，在一个特定的目录下也 &lt;code&gt;touch&lt;&#x2F;code&gt; 出来一个独一无二的文件，并且进度就应该是这个目录下的文件个数除以总的应有的文件个数。那如果文件没有改变怎么办？不会编译，那对应的计数不就没法统计进去了嘛？是的！所以，它还维护了一份总的计数给到一个 &lt;code&gt;target&lt;&#x2F;code&gt; 最后的命令上，这个命令是无论如何都会强制执行的，它会一次 &lt;code&gt;touch&lt;&#x2F;code&gt; 这个 &lt;code&gt;target&lt;&#x2F;code&gt; 应有的全部的文件。比如像这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;makefile&quot; class=&quot;language-makefile &quot;&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;all: lib.a
.PHONY: all

lib.a: a.o b.o c.o d.o e.o
  @jk-print --number=1,2,3,4,5,6 &amp;#x27;lib.a&amp;#x27;
  ...

a.o: a.cpp a.h
  @jk-print --number=1 &amp;#x27;compiling a.cpp&amp;#x27;
  ...

b.o: b.cpp b.h
  @jk-print --number=2 &amp;#x27;compiling b.cpp&amp;#x27;
  ...

c.o: c.cpp c.h
  @jk-print --number=3 &amp;#x27;compiling c.cpp&amp;#x27;
  ...

d.o: d.cpp d.h
  @jk-print --number=4 &amp;#x27;compiling d.cpp&amp;#x27;
  ...

e.o: e.cpp e.h
  @jk-print --number=5 &amp;#x27;compiling e.cpp&amp;#x27;
  ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样就可以完美的把没有进行编译的文件的都补上了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;compile-database&quot;&gt;compile database&lt;&#x2F;h3&gt;
&lt;p&gt;现在在生成 &lt;code&gt;Unix Makefile&lt;&#x2F;code&gt; 的同时，还会在项目的根目录生成一个 &lt;code&gt;compile_commands.json&lt;&#x2F;code&gt; 文件，作为其他 &lt;code&gt;clang-base&lt;&#x2F;code&gt; 的工具的基础。你可以把它和比如 &lt;code&gt;clangd&lt;&#x2F;code&gt; 或者 &lt;code&gt;ccls&lt;&#x2F;code&gt; 来配合。提供项目代码的补全、提示个高亮之类的功能。当然，如果你会自己写一些工具的话，就更好了！&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nei-zhi-de-cmake-base-de-di-san-fang-ku-zhi-chi&quot;&gt;内置的 &lt;code&gt;cmake-base&lt;&#x2F;code&gt; 的第三方库支持&lt;&#x2F;h3&gt;
&lt;p&gt;原本使用一个第三方库，那可麻烦了。我们要自己写一个用来下载安装这个第三方库的一个脚本。自己要小心的处理好，下载文件的逻辑，是不是使用的代理。文件下载之后是不是完整，要不要进行 &lt;code&gt;md5&lt;&#x2F;code&gt; 校验。文件怎么解压，包括后面的 &lt;code&gt;cmake&lt;&#x2F;code&gt; 命令怎么搞，怎么填写这一系列事情。虽然我尝试将一部分工作，封装在了一些内置的包里面，但是依旧有点麻烦。所以这次趁着重写，干脆就重新完整的提供了一个内置的支持！&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;cmake_library(
  url = &amp;quot;http:&amp;#x2F;&amp;#x2F;xxxxx.xxx&amp;#x2F;xxx.tar.gz&amp;quot;,
  sha256 = &amp;quot;xxxxxx&amp;quot;,
  type = &amp;quot;tar.gz&amp;quot;,
  header_only = False,
  job = 10,
)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;du-li-de-jin-cheng&quot;&gt;独立的进程&lt;&#x2F;h3&gt;
&lt;p&gt;现在终于不再依赖，所有的项目都是 &lt;code&gt;media_build&lt;&#x2F;code&gt; 的一个子目录了！你可以任意组织你的项目目录，可以随意的把不管是 &lt;code&gt;libray&lt;&#x2F;code&gt; 还是 &lt;code&gt;protocol&lt;&#x2F;code&gt; 都作为一个 &lt;code&gt;sub-project&lt;&#x2F;code&gt; 放在自己的项目目录里，用自己想用的任意方式来管理！&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zui-hou-de-zui-hou&quot;&gt;最后的最后&lt;&#x2F;h2&gt;
&lt;p&gt;不过，现在还在开发过程啦。
还有一些对以前的兼容没有实现。但是这也已经是一个全新的构建系统了！最初搞的时候，不光考虑了兼容，很多新的功能还有参数设计，也参考了 &lt;code&gt;blaze&lt;&#x2F;code&gt;，&lt;code&gt;buck&lt;&#x2F;code&gt; 还有 &lt;code&gt;cmake&lt;&#x2F;code&gt; 的样子。也应该算是取出来这三个里面，我认为用起来比较方便，舒服的部分吧。&lt;&#x2F;p&gt;
&lt;p&gt;不过缺点还是，这个系统的最初目标就是构建服务端的程序的，对于环境方面没有过多的考虑。所以基本不兼容 &lt;code&gt;windows&lt;&#x2F;code&gt;，&lt;code&gt;macos&lt;&#x2F;code&gt; 能不能用还有全看缘分。这个就没啥计划了… 要是恰好能用！那可太好了！&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>关于我</title>
            <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/about/</link>
            <guid>https://twistoy.com/about/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;已经工作的社畜。&lt;&#x2F;li&gt;
&lt;li&gt;退役废柴 ACM 选手。ICPC金牌，EC-Final的废人。&lt;&#x2F;li&gt;
&lt;li&gt;neovim 用户。自己维护了一个没人用的&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;dotvim&quot;&gt;配置&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;会写 C++ 和 Rust。尤其爱 C++。&lt;&#x2F;li&gt;
&lt;li&gt;WOW 玩家，只会玩版本答案。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;projects&quot;&gt;Projects&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;dotvim&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;dotvim&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
没人用的 neovim 配置，太多自己的私货。可以抄抄，别直接扒。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;httl&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;httl&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
收集平时写代码时候的 snippets，可以拿来自己继续用！实验作品，总是紧跟标准，时常更新（取决于工作的摸鱼时间！）。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;jk-build&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&#x2F;jk-build&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;
在用的 makefile generator，为了解决公司在用的那个东西的问题。基本全用 C++ 重写了。有个&lt;a href=&quot;https:&#x2F;&#x2F;twistoy.com&#x2F;posts&#x2F;cpp-build-system&#x2F;&quot;&gt;文章&lt;&#x2F;a&gt;稍微聊了下。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Github Stats:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TwIStOy&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github-readme-stats.vercel.app&#x2F;api?username=TwIStOy&amp;amp;count_private=true&amp;amp;theme=nord&quot; alt=&quot;ReadMe Card&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Reading List</title>
            <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/reading/</link>
            <guid>https://twistoy.com/reading/</guid>
            <description>&lt;h1 id=&quot;tech&quot;&gt;Tech&lt;&#x2F;h1&gt;
&lt;h1 id=&quot;others&quot;&gt;Others&lt;&#x2F;h1&gt;
&lt;h4 id=&quot;done-ou-xiang-shi-ge-2022-09-12&quot;&gt;DONE &lt;a href=&quot;https:&#x2F;&#x2F;weread.qq.com&#x2F;web&#x2F;bookDetail&#x2F;9c932540813ab6fb3g0197a4&quot;&gt;偶像失格&lt;&#x2F;a&gt; 2022-09-12&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;twistoy.com&#x2F;posts&#x2F;oshi-moyu&#x2F;&quot;&gt;推し、燃ゆ&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        <item>
            <title>软件设计哲学(NOTE)</title>
            <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/a-philosophy-of-software-design-note/</link>
            <guid>https://twistoy.com/posts/a-philosophy-of-software-design-note/</guid>
            <description>&lt;h1 id=&quot;red-flags&quot;&gt;RED FLAGS&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;shallow-module&quot;&gt;Shallow Module&lt;&#x2F;h2&gt;
&lt;p&gt;A shallow module is one whose interface is complicated relative to the functionality it provides. Shallow modules don’t help much in the
battle against complexity, because the benefit they provide (not having to learn about how they work internally) is negated by the cost
of learning and using their interfaces. Small modules tend to be shallow.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;information-leakage&quot;&gt;Information Leakage&lt;&#x2F;h2&gt;
&lt;p&gt;Information leakage occurs when the &lt;strong&gt;same knownledge is used in multiple places&lt;&#x2F;strong&gt;, such as two different classed that both understand the
format of a particular type of file.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;temporal-decomposition&quot;&gt;Temporal Decomposition&lt;&#x2F;h2&gt;
&lt;p&gt;In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different
methods or classes. If the same knowledge is used at different points in execution, it get encoded in multiple places, resulting in
information leakage.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overexposure&quot;&gt;Overexposure&lt;&#x2F;h2&gt;
&lt;p&gt;If the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don’t need the rarely used features.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pass-through-method&quot;&gt;Pass-Through Method&lt;&#x2F;h2&gt;
&lt;p&gt;A pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through
method. This typically indicates that there is not a clean division of respoinsibility between the classes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;repetition&quot;&gt;Repetition&lt;&#x2F;h2&gt;
&lt;p&gt;If the same piece of code (or code that is almost the same) appears over and over again, that’s a red flag that you haven’t found the right abstractions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;special-general-mixture&quot;&gt;Special-General Mixture&lt;&#x2F;h2&gt;
&lt;p&gt;This red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the 80 mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conjoined-methods&quot;&gt;Conjoined Methods&lt;&#x2F;h2&gt;
&lt;p&gt;It should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;comment-repeats-code&quot;&gt;Comment Repeats Code&lt;&#x2F;h2&gt;
&lt;p&gt;Red Flag: Comment Repeats Code If the information in a comment is already obvious from the code next to the comment, then the comment isn’t helpful. One example of this is when the comment uses the same words that make up the name of the thing it is describing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation-documentation-contaminates-interface&quot;&gt;Implementation Documentation Contaminates Interface&lt;&#x2F;h2&gt;
&lt;p&gt;This red flag occurs when interface documentation, such as that for a method, describes implementation details that aren’t needed in order to use the thing being documented.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vague-name&quot;&gt;Vague Name&lt;&#x2F;h2&gt;
&lt;p&gt;If a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hard-to-pick-name&quot;&gt;Hard to Pick Name&lt;&#x2F;h2&gt;
&lt;p&gt;If it’s hard to find a simple name for a variable or method that creates a clear image of the underlying object, that’s a hint that the underlying object may not have a clean design.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hard-to-describe&quot;&gt;Hard to Describe&lt;&#x2F;h2&gt;
&lt;p&gt;The comment that describes a method or variable should be simple and yet complete. If you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;excerpt&quot;&gt;EXCERPT&lt;&#x2F;h1&gt;
&lt;h3 id=&quot;definition&quot;&gt;Definition&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Complexity&lt;&#x2F;strong&gt; is anything related to the structure of a software system that makes it hard to understand and modify the system.
$$ C = \sum_{p}c_pt_p $$
The overall complexity of a system $(C)$ is determined by the complexity of each part $p(c_p)$ weighted by the faction of time
developers spend working on the part $(t_p)$.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;symptoms&quot;&gt;Symptoms&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Change amplification&lt;&#x2F;strong&gt;: The first symptom of complexity is that a seemingly simple change requires code modifications in
many different places.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Cognitive load&lt;&#x2F;strong&gt;: The second symptom of complexity is cognitive load, which refers to how much a developer needs to know
in order to complete a task.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Unknown unknowns&lt;&#x2F;strong&gt;: The third symptom of complexity is that it is not obvious which pieces of code must be modified to
complete a task, or what information a developer must have to carry out the task successfully.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;modules&quot;&gt;Modules&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;In this world, the complexity of a system would be the complexity of its worst module.&lt;&#x2F;li&gt;
&lt;li&gt;The interface describes &lt;em&gt;what&lt;&#x2F;em&gt; the module does but not &lt;em&gt;how&lt;&#x2F;em&gt; it does it.&lt;&#x2F;li&gt;
&lt;li&gt;The best modules are those whose interfaces are much simpler than their implementations.&lt;&#x2F;li&gt;
&lt;li&gt;An &lt;strong&gt;abstraction&lt;&#x2F;strong&gt; is a simplified view of an entity, which omits unimportant details.&lt;&#x2F;li&gt;
&lt;li&gt;Interface:
&lt;ul&gt;
&lt;li&gt;The interface to a module contains two kinds of information: &lt;strong&gt;formal&lt;&#x2F;strong&gt; and &lt;strong&gt;informal&lt;&#x2F;strong&gt;.
&lt;ul&gt;
&lt;li&gt;The formal parts of an interface are specified explicitly in the code, and some of these can be checked for correctness
by the programming language.&lt;&#x2F;li&gt;
&lt;li&gt;The informal parts of an interface includes its high-level behavior, such as the fact that a function deletes the file named by
one of its arguments.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;In modular programming, each module provides an abstraction in form of its interface. The interface presents a simplified view of the module’s functionality; the details of the implementation are unimportant from the standpoint of the module’s abstraction, so they are omitted from the interface. &lt;strong&gt;A detail can only be omiited from an abstraction if it is unimportant.&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The best modules are those that provide powerful functionality yet have simple interfaces: they have a lot of functionality hidden behind
a simple interface. A deep module is a good abstraction because only a small fraction of its internal complexity is visible to its users.&lt;&#x2F;li&gt;
&lt;li&gt;Classitis may result in classes that are individually simple, but it increases the complexity of the overall system. Small classes don’t contribute much functionality, so there have to be a lot of them, each with its own interface. These interfaces accumulate to create tremendous complexity at the system level.&lt;&#x2F;li&gt;
&lt;li&gt;Provide choice is good, but &lt;strong&gt;interfaces should be designed to make the common case as simple as possible&lt;&#x2F;strong&gt;. If an interface has many
features, but most developers only need to be aware of a few of them, the effective complexity of that interface is just the complexity
of the commonly used features.&lt;&#x2F;li&gt;
&lt;li&gt;The most important (and perhaps surprising) benefit of the general- purpose approach is that it results in simpler and deeper interfaces than a special-purpose approach. The general-purpose approach can also save you time in the future, if you reuse the class for other purposes. However, even if the module is only used for its original purpose, the general-purpose approach is still better because of its simplicity.&lt;&#x2F;li&gt;
&lt;li&gt;Questions to ask yourself
&lt;ul&gt;
&lt;li&gt;What is the simplest interface that will cover all my current needs?&lt;&#x2F;li&gt;
&lt;li&gt;In how many situations will this method be used?&lt;&#x2F;li&gt;
&lt;li&gt;Is this API easy to use for my current needs?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Decorators
&lt;ul&gt;
&lt;li&gt;A decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the underlying object.&lt;&#x2F;li&gt;
&lt;li&gt;Before creating a decorator class, consider alternatives such as the following:
&lt;ul&gt;
&lt;li&gt;Could you add the new functionality directly to the underlying class, rather than creating a decorator class?&lt;&#x2F;li&gt;
&lt;li&gt;If the new functionality is specialized for a particular use case, would it make sense to merge it with the use case, rather than creating a separate class?&lt;&#x2F;li&gt;
&lt;li&gt;Could you merge the new functionality with an existing decorator, rather than creating a new decorator?&lt;&#x2F;li&gt;
&lt;li&gt;Finally, ask yourself whether the new functionality really needs to wrap the existing functionality: could you implement it as a stand-alone class that is independent of the base class?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;together-vs-apart&quot;&gt;Together vs Apart&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Bring together if information is shared&lt;&#x2F;li&gt;
&lt;li&gt;Bring together if it will simplify the interface&lt;&#x2F;li&gt;
&lt;li&gt;Bring together to eliminate duplication&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;comments&quot;&gt;Comments&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Documentation also plays an important role in abstraction; without comments, you can’t hide complexity.&lt;&#x2F;li&gt;
&lt;li&gt;If users must read the code of a method in order to use it, then there is no abstraction: all of the complexity of the method is exposed.&lt;&#x2F;li&gt;
&lt;li&gt;Many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;The overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code.&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Comments should describe things that aren’t obvious from the code.&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;One of the most important reasons for comments is abstractions, which include a lot of information that isn’t obvious from the code.&lt;&#x2F;li&gt;
&lt;li&gt;Developers should be able to understand the abstraction provided by a module without reading any code other than its externally visible declarations.&lt;&#x2F;li&gt;
&lt;li&gt;Comments categories:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Interface&lt;&#x2F;strong&gt;: a comment block that immediately precedes the declaration of a module such as a class, data structure, function, or method. The comment describe’s the module’s interface.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Data structure member&lt;&#x2F;strong&gt;: a comment next to the declaration of a field in a data structure, such as an instance variable or static variable for a class.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Implementation comment&lt;&#x2F;strong&gt;: a comment inside the code of a method or function, which describes how the code works internally.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Cross-module comment&lt;&#x2F;strong&gt;: a comment describing dependencies that cross module boundaries.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;After you have written a comment, ask yourself the following question: could someone who has never seen the code write the comment just by looking at the code next to the comment? If the answer is yes, as in the examples above, then the comment doesn’t make the code any easier to understand. Comments like these are why some people think that comments are worthless.&lt;&#x2F;li&gt;
&lt;li&gt;Comments augment the code by providing information at a different level of detail.
&lt;ul&gt;
&lt;li&gt;Precision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values. The name and type in a variable declaration are typically not very precise. Comments can fill in missing details such as:
&lt;ul&gt;
&lt;li&gt;What are the units for this variable?&lt;&#x2F;li&gt;
&lt;li&gt;Are the boundary conditions inclusive or exclusive?&lt;&#x2F;li&gt;
&lt;li&gt;If a null value is permitted, what does it imply?&lt;&#x2F;li&gt;
&lt;li&gt;If a variable refers to a resource that must eventually be freed or closed, who is responsible for freeing or closing it?&lt;&#x2F;li&gt;
&lt;li&gt;Are there certain properties that are always true for the variable (invariants), such as “this list always contains at least one entry”?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;When documenting a variable, think nouns, not verbs. In other words, focus on what the variable represents, not how it is manipulated.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;The best time to write comments is at the beginning of the process, as you write the code&lt;&#x2F;strong&gt;. Writing the comments first makes documentation part of the design process. Not only does this produce better documentation, but it also produces better designs and it makes the process of writing documentation more enjoyable.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;interface-comments&quot;&gt;Interface Comments&lt;&#x2F;h4&gt;
&lt;p&gt;The interface comment for a method includes both higher-level information for abstraction and lower-level details for precision:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The comment usually starts with a sentence or two describing the behavior of the method as perceived by callers; this is the higher-level abstraction.&lt;&#x2F;li&gt;
&lt;li&gt;The comment must describe each argument and the return value (if any).
These comments must be very precise, and must describe any constraints on argument values as well as dependencies between arguments.&lt;&#x2F;li&gt;
&lt;li&gt;If the method has any side effects, these must be documented in the interface comment. A side effect is any consequence of the method that affects the future behavior of the system but is not part of the result. For example, if the method adds a value to an internal data structure, which can be retrieved by future method calls, this is a side effect; writing to the file system is also a side effect.&lt;&#x2F;li&gt;
&lt;li&gt;A method’s interface comment must describe any exceptions that can emanate from the method.&lt;&#x2F;li&gt;
&lt;li&gt;If there are any preconditions that must be satisfied before a method is invoked, these must be described (perhaps some other method must be invoked first; for a binary search method, the list being searched must be sorted). It is a good idea to minimize preconditions, but any that remain must be documented.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;implementation-comments&quot;&gt;Implementation Comments&lt;&#x2F;h4&gt;
&lt;p&gt;The main goal of implementation comments is to help readers understand &lt;em&gt;what&lt;&#x2F;em&gt; the code is doing (not how it does it).&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Paxos Note</title>
            <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/paxos-note/</link>
            <guid>https://twistoy.com/posts/paxos-note/</guid>
            <description>&lt;h2 id=&quot;symbols-and-structure&quot;&gt;Symbols And Structure&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;表决 $B$&lt;pre data-lang=&quot;rs&quot; class=&quot;language-rs &quot;&gt;&lt;code class=&quot;language-rs&quot; data-lang=&quot;rs&quot;&gt;struct Ballot {
  dec: Decree,      &amp;#x2F;&amp;#x2F; 表决的内容
  vot: Set&amp;lt;Node&amp;gt;,   &amp;#x2F;&amp;#x2F; 表决投票通过的节点
  qrm: Set&amp;lt;Node&amp;gt;,   &amp;#x2F;&amp;#x2F; 表决参与的节点
  bal: u64,         &amp;#x2F;&amp;#x2F; 表决编号
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
A ballot is said to be successful, if every quorum member voted. In math:
$$ B_{qrm} \subseteq B_{vot} $$&lt;&#x2F;li&gt;
&lt;li&gt;投票 $v$&lt;pre data-lang=&quot;rs&quot; class=&quot;language-rs &quot;&gt;&lt;code class=&quot;language-rs&quot; data-lang=&quot;rs&quot;&gt;struct Vote {
  pst: Node,        &amp;#x2F;&amp;#x2F; 本投票的节点
  bal: u64,         &amp;#x2F;&amp;#x2F; 本投票的表决编号
  dec: Decree,      &amp;#x2F;&amp;#x2F; 本投票表决的内容
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;表决的集合 $\beta$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;define-some-useful-functions&quot;&gt;Define Some Useful functions&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;$Votes(\beta)$：所有在 $\beta$ 中的表决的投票的集合
$$Votes(\beta) = \{v:(v_{pst}\in B_{vot})\cap(v_{bal}=B_{bal}), B \in \beta\}$$&lt;&#x2F;li&gt;
&lt;li&gt;$Max(b, p, \beta)$：在由节点 $p$ 投给 $\beta$ 中的表决的投票中，编号小与等于 $b$ 的最大投票
$$Max(b, p,\beta)=max\{v \in Votes(\beta):(v_{pst}=p)\land(v_{bal}&amp;lt;b)\}\cup\{null_{p}\}$$&lt;&#x2F;li&gt;
&lt;li&gt;$MaxVote(b, Q, \beta)$：在集合 $Q$ 中的任意一个节点投给 $\beta$ 中的表决的投票中，编号小于等于 $b$ 的最大投票
$$MaxVote(b,Q,\beta)=max\{v\in Votes(\beta):(v_{pst}\in Q)\cap(v_{val}&amp;lt;b)\}\cup\{null_p\}$$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;那么如果条件$B1(\beta)-B3(\beta)$满足的情况下，那么系统将满足一致性，并且是可进展的。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$B1(\beta) \triangleq \forall B,B&#x27; \in \beta:(B \ne B&#x27;) \implies (B_{bal} \ne B&#x27;_{bal})$&lt;&#x2F;li&gt;
&lt;li&gt;$B2(\beta) \triangleq \forall B,B&#x27; \in \beta:B_{qrm}\cap B&#x27;_{qrm} \ne \emptyset $&lt;&#x2F;li&gt;
&lt;li&gt;$B3(\beta) \triangleq \forall B \in \beta: (MaxVote(B_{bal},B_{qrm},\beta)_{bal}\ne - \infty) \implies B_{dec} = MaxVote(B_{bal}, B_{qrm}, \beta)_{dec} $&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;lemma-1&quot;&gt;Lemma 1&lt;&#x2F;h3&gt;
&lt;p&gt;如果 $\beta$ 中的表决 $B$ 是成功的，那么 $\beta$ 中更大编号的表决和 $B$ 的表决内容相同。
$$ ((B_{qrm} \subseteq B_{vot})\land(B&#x27;_{bal}&amp;gt;B_{bal})) \implies (B&#x27;_{dec}=B_{dec}) $$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;&#x2F;h3&gt;
&lt;p&gt;定义集合 $\Psi(B, \beta)$: $\Psi(B, \beta) \triangleq \{B&#x27;\in \beta:(B&#x27;_{bal}&amp;gt;B_{bal})\land(B&#x27;_{dec}\ne B_{dec}) \}$，表示 $\beta$ 中编号比 $B$ 大并且表决内容不相同的表决的集合。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;$ C = min\{B&#x27;:B&#x27;\in \Psi(B, \beta)\} $&lt;&#x2F;li&gt;
&lt;li&gt;$ C_{bal} &amp;lt; B_{bal} $&lt;&#x2F;li&gt;
&lt;li&gt;$ C_{qrm} \cap B_{bot} \ne \emptyset $
因为 $B2$ 和 假设中的 $B$ 表决是成功的，也就是 $ B_{qrm} \subseteq B_{vot} $&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal},C_{qrm},\beta)_{bal} \ge B_{bal} $
因为 $C_{qrm}$ 和 $B$ 的投票者一定有交集&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal}, C_{qrm}, \beta)\in Votes(\beta)$&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal}, C_{qrm}, \beta)_{dec} = C_{dec} $&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal}, C_{qrm}, \beta)_{dec} \ne B_{dec} $&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal}, C_{qrm}, \beta)_{bal} &amp;gt; B_{bal} $&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal}, C_{qrm}, \beta) \in Votes(\Psi(B, \beta)) $&lt;&#x2F;li&gt;
&lt;li&gt;$ MaxVote(C_{bal}, C_{qrm}, \beta)_{bal} &amp;lt; C_{bal} $&lt;&#x2F;li&gt;
&lt;li&gt;9, 10 和 1 矛盾。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;ding-li-1&quot;&gt;定理 1&lt;&#x2F;h3&gt;
&lt;p&gt;在满足 $B1(\beta)$，$B2(\beta)$，$B3(\beta)$ 的情况下，
$$((B_{qrm} \subseteq B_{vot})\land(B&#x27;_{qrm}\subseteq B&#x27;_{vot})) \implies (B&#x27;_{dec} = B_{dec}) $$&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ding-li-2&quot;&gt;定理 2&lt;&#x2F;h3&gt;
&lt;p&gt;$$ \forall B\in\beta, b &amp;gt; B_{bal}, Q \cap B_{qrm} \ne \emptyset $$ 如果 $B1(\beta)$，$B2(\beta)$，$B3(\beta)$ 满足，那么存在一个 $ B&#x27;, B&#x27;_{bal}=b, B&#x27;_{qrm}=B&#x27;_{vot}=Q $ 使得 $B1(\beta\cup\{B&#x27;\})$，$B2(\beta\cup\{B&#x27;\})$，$B3(\beta\cup\{B&#x27;\})$ 成立。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>关于 cpp 可见性的黑魔法后门</title>
            <pubDate>Thu, 14 May 2020 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/black-magic-of-private-backdoor/</link>
            <guid>https://twistoy.com/posts/black-magic-of-private-backdoor/</guid>
            <description>&lt;p&gt;这个点子是我最初在网上其他地方看到的，感觉很好玩。就记录一下啦。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Reference:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;cpp.kjx.cz&#x2F;private_backdoor.html&quot;&gt;http:&#x2F;&#x2F;cpp.kjx.cz&#x2F;private_backdoor.html&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>一个关于 private member function detect 的 SFINAE 模板</title>
            <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/private-member-function-detect-template-with-sfinae/</link>
            <guid>https://twistoy.com/posts/private-member-function-detect-template-with-sfinae/</guid>
            <description>&lt;h1 id=&quot;wen-ti-de-kai-shi&quot;&gt;问题的开始&lt;&#x2F;h1&gt;
&lt;p&gt;问题起源于，我要搞一个模板，来检查一个类，是不是有一个特定的回调接口 &lt;code&gt;OnAlarm()&lt;&#x2F;code&gt;。我显然希望在我的模板类里面，直接调用这个 &lt;code&gt;OnAlarm&lt;&#x2F;code&gt; 回调的。但是问题，就这么出现了。我需要一个模板，来检查一个传给构造函数的指针指向的类型，是不是有我需要的 &lt;code&gt;OnAlarm&lt;&#x2F;code&gt; 方法。如果没有的话，我需要使用另一套回调的机制。
问题就出在了这个检查上面。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;wen-ti-de-zui-chu-de-yang-zi&quot;&gt;问题的最初的样子&lt;&#x2F;h1&gt;
&lt;p&gt;最开始的时候，我是写成了这个样子的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;template &amp;lt;typename T, typename = void&amp;gt;
struct HasAlarmCallback : std::false_type {};

template &amp;lt;typename T&amp;gt;
struct HasAlarmCallback&amp;lt;T, decltype(std::declval&amp;lt;T&amp;gt;().OnAlarm())&amp;gt;
    : std::true_type {};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样看起来是没问题的（其实也是没问题的），但是我遇到了第一个问题。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class B {
  void OnAlarm() {}
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个模板在 &lt;code&gt;T = B&lt;&#x2F;code&gt; 的时候，会有编译错误，并不能成功的使用 SFINAE。错误的内容大概就是，这里用了一个 private 的函数，然后是不可见的。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;shu-guang&quot;&gt;曙光&lt;&#x2F;h1&gt;
&lt;p&gt;（虽然也不知道为什么）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;typename T, typename = void&amp;gt;
struct HasAlarmCallback : std::false_type {};

template &amp;lt;typename T&amp;gt;
struct HasAlarmCallback&amp;lt;T, decltype(static_cast&amp;lt;T*&amp;gt;(nullptr)-&amp;gt;OnAlarm())&amp;gt;
    : std::true_type {};

struct A {
  void OnAlarm(){};
};

class B {
  void OnAlarm(){};
};

int main() {
  HasAlarmCallback&amp;lt;A&amp;gt; a;
  HasAlarmCallback&amp;lt;B&amp;gt; b;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在我这样写的时候，代码是可以完美通过编译，并且可以完美运行的。结果也是完美符合预期的。那我就会想呀，为啥我直接像下面样子写就不对了呢～&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;std::cout &amp;lt;&amp;lt; HasAlarmCallback&amp;lt;A&amp;gt;::value &amp;lt;&amp;lt; std::endl;
std::cout &amp;lt;&amp;lt; HasAlarmCallback&amp;lt;B&amp;gt;::value &amp;lt;&amp;lt; std::endl;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;！！！这是我百思不得其解的要点！！！
在我这么写的时候，就不 work，会报像最开始那样的编译问题。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zui-hou-de-fang-an&quot;&gt;最后的方案&lt;&#x2F;h1&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T, typename = void&amp;gt;
struct _HasAlarmCallback {
  static constexpr bool value = false;
};

template&amp;lt;typename T&amp;gt;
struct _HasAlarmCallback&amp;lt;T, decltype(static_cast&amp;lt;T *&amp;gt;(nullptr)-&amp;gt;OnAlarm())&amp;gt; {
  static constexpr bool value = true;
};

template&amp;lt;typename T&amp;gt;
struct HasAlarmCallback {
 private:
  static constexpr _HasAlarmCallback&amp;lt;T&amp;gt; foo{};

 public:
  static constexpr bool value = _HasAlarmCallback&amp;lt;T&amp;gt;::value;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我最后发现，如果需要我构造一个实例才能解决这个问题的话，那我就构造一个。
嗯… 虽然… 不知道为啥…
反正是 work 了…&lt;&#x2F;p&gt;
&lt;p&gt;如果有人看到，然后知道为什么的话… 请告诉我！谢谢了！&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>User-defined conversion and Copy elision</title>
            <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/user-defined-conversion-and-copy-elision/</link>
            <guid>https://twistoy.com/posts/user-defined-conversion-and-copy-elision/</guid>
            <description>&lt;h1 id=&quot;wen-ti-de-kai-shi&quot;&gt;问题的开始&lt;&#x2F;h1&gt;
&lt;p&gt;问题的开始是同事聊到了我们笔试题的一个问题，是说下面这个代码其实在编译的时候是有问题的。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;struct UserInfo {
  UserInfo(const std::string&amp;amp; name) : name_(name) {}

 private:
  std::string name_;
};

int main() {
  UserInfo u = &amp;quot;name&amp;quot;;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;zui-chu-de-tao-lun-he-si-kao&quot;&gt;最初的讨论和思考&lt;&#x2F;h1&gt;
&lt;p&gt;显然在最开始的时候，我并没有发现这个代码的问题所在，并且被告知了在这段代码里面其实是有两个问题的。&lt;&#x2F;p&gt;
&lt;p&gt;在这个简单的例子里面，就涉及到了在规范里面两个很不容易注意到的行为，就像标题里聊的 &lt;code&gt;UDC(user-defined conversion)&lt;&#x2F;code&gt; 和 &lt;code&gt;copy-elision&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-yu-yin-shi-zhuan-huan-implicit-conversion&quot;&gt;关于隐式转换（implicit conversion）&lt;&#x2F;h2&gt;
&lt;p&gt;在 &lt;code&gt;main&lt;&#x2F;code&gt; 函数里面唯一的语句，这首先是一个变量的声明和定义，同时还包括了这个变量的初始化（initialize）。在这个变量的初始化阶段，发生了几次类型转换，其中大部分都是隐式的（&lt;code&gt;implicit conversion&lt;&#x2F;code&gt;），并且调用到了不同的构造函数：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;const char[5] =[implicit conversion(1)]=&amp;gt; std::string
              =[implicit conversion(2)]=&amp;gt; UserInfo
              =[copy&amp;#x2F;move(3)]=&amp;gt; UserInfo
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一次发生在字符串字面量（string literal）构造 &lt;code&gt;std::string&lt;&#x2F;code&gt; 的时候，显然这是一个隐式转换，因为并没有显式的调用 &lt;code&gt;std::string&lt;&#x2F;code&gt; 的构造函数，并且这个隐式转换显然是 &lt;code&gt;user-defined&lt;&#x2F;code&gt; 的。&lt;&#x2F;p&gt;
&lt;p&gt;第二次发生在 &lt;code&gt;std::string&lt;&#x2F;code&gt; 构造一个 &lt;code&gt;UserInfo&lt;&#x2F;code&gt; 的时候，这也是一个隐式转换，并且是 &lt;code&gt;user-defined&lt;&#x2F;code&gt; 的。&lt;&#x2F;p&gt;
&lt;p&gt;这两次隐式转换构成了一个隐式转换链（&lt;code&gt;implicit-conversion sequence&lt;&#x2F;code&gt;），问题就出在这个由两个 &lt;code&gt;user-defined conversion&lt;&#x2F;code&gt; 构成的隐式转换链上。在标准的 &lt;code&gt;16.3.3.1&lt;&#x2F;code&gt; 里讨论了有关于 &lt;code&gt;implicit conversion&lt;&#x2F;code&gt; 和 &lt;code&gt;user-defined conversion&lt;&#x2F;code&gt; 的部分，而在 &lt;code&gt;15.3&lt;&#x2F;code&gt; 里特别提到了：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;At most one user-defined conversion (constructor or conversion functions) is implicitly applied to a single value.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在一个隐式转换序列里，只能存在最多一个用户定义的转换。这个条件在标准的隐藏的很深，我在通读标准的时候几次都错过了他们。（但是据说这个问题，曾经在邮件列表里有过蛮激烈的讨论的，但是可惜我那个时候还是个孩子hhh）&lt;&#x2F;p&gt;
&lt;p&gt;所以在这个问题里，发生 ill-formed 的第一个原因是，在一个 implicit conversion sequence 里面，存在多个 user-defined conversion。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-yu-fu-zhi-xiao-chu-copy-elision&quot;&gt;关于复制消除（copy elision）&lt;&#x2F;h2&gt;
&lt;p&gt;关于复制消除的部分，这里就要提到不同的两个版本，C++17 开始和 C++17 之前。&lt;&#x2F;p&gt;
&lt;p&gt;在 C++17 之前，并没有明确的提出在什么情况下，可以彻底进行复制消除（这里的彻底的指的是包括不进行是否有可用的 copy&#x2F;move 构造函数的检查）。&lt;&#x2F;p&gt;
&lt;p&gt;所以在 C++17 之前，下面的这段代码是会有编译错误的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;struct Foo {
  Foo(int) {}
  Foo(Foo&amp;amp;&amp;amp;) = delete;
  Foo(const Foo&amp;amp;) = delete;
};

int main() {
  Foo a = 1;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以考虑上面给出的上面那个问题的隐式转换链，这个首先出现的是 source type 的 target type 的不一致，所以出现了一次 user-defined 的 implicit conversion。从类型 &lt;code&gt;int&lt;&#x2F;code&gt; 得到了类型 &lt;code&gt;Foo&lt;&#x2F;code&gt; 的一个 &lt;code&gt;prvalue&lt;&#x2F;code&gt;（这里的 &lt;code&gt;prvalue&lt;&#x2F;code&gt; 很重要）。然后才是从一个 &lt;code&gt;prvalue&lt;&#x2F;code&gt; 构造一个类型 &lt;code&gt;Foo&lt;&#x2F;code&gt; 的对象。&lt;&#x2F;p&gt;
&lt;p&gt;其实我们显然可以知道，第二个过程是会被优化掉的，一般的编译器都会优化成原地构造的。但是标准在这个时候要求了，在这种时候，即使这部分的内容会优化，但是依旧要进行编译时的检查，检查 copy&#x2F;move 构造函数是否可用，如果不可用，那这个代码依旧是 ill-formed。&lt;&#x2F;p&gt;
&lt;p&gt;但是事情在 C++17 中发成了一个很大的改变 &lt;code&gt;11.6.4.3.9&lt;&#x2F;code&gt;，在一个是 prvalue 的时候，这里会用 direct-initalize，而不是尝试使用 copy&#x2F;move initialize。也就是说，上面例子的代码在 C++17 之后其实是可以通过编译的。&lt;&#x2F;p&gt;
&lt;p&gt;但是这里要注意，适用的规则是一个 prvalue 的对象，xrvalue 是不可以的。也就是说，下面这样的代码依旧是不能通过编译的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;struct Foo {
  Foo(int = 10) {}

  Foo(Foo&amp;amp;&amp;amp;) = delete;
  Foo(const Foo&amp;amp;) = delete;
};
struct Bar {
  operator Foo&amp;amp;&amp;amp; {
    return std::move(a);
  }
  
  Foo a;
};

int main() {
  Bar b;
  Foo a = b;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里虽然做了一次隐式类型转换（从 &lt;code&gt;Bar&lt;&#x2F;code&gt; 到 &lt;code&gt;Foo&lt;&#x2F;code&gt;），但是得到的类型是一个 xrvalue，而 xrvalue 是不适合上面的拷贝消除规则的，所以还会尝试使用 copy&#x2F;move 构造，得到 ill-formed 的结果。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;文中提到的所有标准文档，都采用最新的 C++ 标准文档（ISO&#x2F;IEC 14882 2017），除非特别指定此时讨论的C++版本。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>VIM and Latex</title>
            <pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/vim-and-latex/</link>
            <guid>https://twistoy.com/posts/vim-and-latex/</guid>
            <description>&lt;h1 id=&quot;qi-yuan&quot;&gt;起源&lt;&#x2F;h1&gt;
&lt;p&gt;起源是在群里看到了有人分享的关于一个人用 &lt;code&gt;vim&lt;&#x2F;code&gt; 写 &lt;code&gt;latex&lt;&#x2F;code&gt; 的文章，但是它的做法是用了一个 &lt;code&gt;vimtex&lt;&#x2F;code&gt; 的独立插件。
我是个 language server 的狂热使用者，所以我就在找一个用 language server 的处理方案。回忆起来另一次在另一个群里看到的，一个叫做 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;latex-lsp&#x2F;texlab&quot;&gt;texlab&lt;&#x2F;a&gt; 的项目，就在 vim 里搞个配合。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;vim-li-de-cha-jian-xuan-ze&quot;&gt;vim 里的插件选择&lt;&#x2F;h1&gt;
&lt;p&gt;vim 里的 language client 的实现用好几种：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prabirshrestha&#x2F;vim-lsp&quot;&gt;vim-lsp&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;neoclide&#x2F;coc.nvim&quot;&gt;coc.nvim&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;autozimu&#x2F;LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;用来用去还是 &lt;code&gt;coc.nvim&lt;&#x2F;code&gt; 在这里面不论是流畅度还是 feature 的丰富程度都是比较好的。所以我也一直在用。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;install&quot;&gt;Install&lt;&#x2F;h1&gt;
&lt;p&gt;install &lt;code&gt;coc.nvim&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;call dein#add(&amp;#x27;neoclide&amp;#x2F;coc.nvim&amp;#x27;, {&amp;#x27;build&amp;#x27;: &amp;#x27;yarn install&amp;#x27;})
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;install &lt;code&gt;texlab&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;latex-lsp&amp;#x2F;texlab
yarn install &amp;amp;&amp;amp; yarn build
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;config&quot;&gt;config&lt;&#x2F;h1&gt;
&lt;p&gt;config in coc.nvim&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&amp;quot;texlab&amp;quot;: {
  &amp;quot;command&amp;quot;: &amp;quot;node&amp;quot;,
  &amp;quot;args&amp;quot;: [
    &amp;quot;&amp;#x2F;path&amp;#x2F;to&amp;#x2F;texlab&amp;#x2F;dist&amp;#x2F;texlab.js&amp;quot;, &amp;quot;--stdio&amp;quot;
  ],
  &amp;quot;filetypes&amp;quot;: [&amp;quot;tex&amp;quot;, &amp;quot;plaintex&amp;quot;],
  &amp;quot;trace.server&amp;quot;: &amp;quot;verbose&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>Compare Between CRTP and Virtual</title>
            <pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/compare-between-crtp-and-virtual/</link>
            <guid>https://twistoy.com/posts/compare-between-crtp-and-virtual/</guid>
            <description>&lt;p&gt;我们平时都会使用虚函数来实现 C++ 里的运行时的多态，但是虚函数会带来很多性能上面的问题：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;虚函数的调用需要额外的寻址&lt;&#x2F;li&gt;
&lt;li&gt;虚函数不能被 inline，当使用比较小的虚函数的时候会带来很严重的性能负担&lt;&#x2F;li&gt;
&lt;li&gt;需要在每个对象中维护一个额外的虚函数表&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;但是在有些情况下，我们就可以用一些静态的类型分发策略来带来一些性能上面的好处。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;yi-ge-chuan-tong-de-li-zi&quot;&gt;一个传统的例子&lt;&#x2F;h1&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct VirtualInterface {
  virtual void Skip(uint32_t steps) = 0;
};

struct VirtualImpl : public VirtualInterface {
  uint32_t index_;

  void Skip(uint32_t steps) override { index_ += steps; index_ %= INT_MAX; }
};

void VirtualRun(VirtualInterface* interface) {
  for (auto i = 0; i &amp;lt; N; i++) {
    for (auto j = 0; j &amp;lt; i; j++) {
      interface-&amp;gt;Skip(j);
    }
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里有一个很简单的例子，我们搞了一个简单的计数类来模拟这个过程。首先使用虚函数的方法去实现这个。在开了O2的情况下，运行了 3260628226 ns。&lt;&#x2F;p&gt;
&lt;p&gt;然后我们使用 CRTP 来实现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;typename Impl&amp;gt;
struct CrtpInterface {
  void Skip(uint32_t steps) { static_cast&amp;lt;Impl*&amp;gt;(this)-&amp;gt;Skip(steps); }
};

struct CrtpImpl : public CrtpInterface&amp;lt;CrtpImpl&amp;gt; {
  void Skip(uint32_t steps) {
    index_ += steps;
    index_ %= INT_MAX;
  }

  uint32_t index_ = 0;
};

template &amp;lt;typename T&amp;gt;
void CrtpRun(CrtpInterface&amp;lt;T&amp;gt;* interface) {
  for (auto i = 0; i &amp;lt; N; i++) {
    for (auto j = 0; j &amp;lt; i; j++) {
      interface-&amp;gt;Skip(j);
    }
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;同样运行我们的代码， 29934437 ns。
显然在省去了查虚函数表，并且可以inline的情况下，程序有了更好的表现。&lt;&#x2F;p&gt;
&lt;p&gt;在具体的实现方式上，参考上面的实现就可以了…&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Interface in C++</title>
            <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/interface-in-cpp/</link>
            <guid>https://twistoy.com/posts/interface-in-cpp/</guid>
            <description>&lt;h1 id=&quot;interface-in-c&quot;&gt;Interface In C++&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;wen-ti-ti-chu&quot;&gt;问题提出&lt;&#x2F;h2&gt;
&lt;p&gt;我记得我不止一次提到说，我更喜欢 golang 的泛型设计。一个优秀的泛型系统，我希望是来表示一个方法可以接受什么。应该是一个类似于 concept 的概念。我们都知道，在 C++ 里面，我们更多的使用虚函数来实现这个功能，就像下面这样：&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct IPerson {
  virtual std::string Name() = 0;
  virtual uint32_t Age() = 0;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们搞了一个几个纯虚函数来表示一个接口类，然后我们都会搞一些类来继承这个类，就像下面这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct Student : public IPerson {
  std::string Name() override;
  uint32_t Age() override;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那在使用的地方：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void Foo(IPerson*);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这已经是我们一般在写代码时候的常规做法了，但是在这样的情况下，我们要求了所有使用这个的地方，都只能使用指针或者引用。因为我们不能对一个对象来搞这些东西。&lt;&#x2F;p&gt;
&lt;p&gt;再回想一下，golang 的泛型的样子，我们有没有一个办法，可以搞一个类似于 &lt;code&gt;interface&lt;&#x2F;code&gt; 的东西来让一个对象也可以表示这些东西呢？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-dan-si-kao-1&quot;&gt;简单思考1&lt;&#x2F;h2&gt;
&lt;p&gt;基于上面的问题，考虑这个问题的背后是表示的是个什么类型的多态问题。Ok，显然是个运行时多态。编译时多态的问题可以配合 &lt;code&gt;template&lt;&#x2F;code&gt;, &lt;code&gt;constexpr&lt;&#x2F;code&gt; 来解决。那么运行时多态在原本的 C++ 是通过虚函数来解决的。虚函数的实现，又是通过一个虚函数表来实现的。那么问题来了，我们可不可以自己来维护一个虚函数表来达到我们想要的效果呢？
上面我们需要的接口类，显然我们可以提炼出来一个这样的虚函数表：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct vtable {
  std::string (*Name)(void*);
  uint32_t (*Age)(void*);
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个虚函数表表示了这个接口需要哪些接口，在这里使用 &lt;code&gt;void*&lt;&#x2F;code&gt; 来表示任意类型的指针。
那有了这个虚函数表之后，我们应该怎么使用这个呢？就像这个这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
vtable vtable_for = {
  [](void* p) {
    return static_cast&amp;lt;T*&amp;gt;(p)-&amp;gt;Name();
  },
  [](void*) {
    return static_cast&amp;lt;T*&amp;gt;(p)-&amp;gt;Age();
  },
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里用了 C++14 的新特性：变量模板，来构造了一个静态的全局变量，来表示对应的制定类型的虚函数表实现。
在有了上面两个东西的基础上，就得到了接口类的实现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct Person {
  template&amp;lt;typename T&amp;gt;
  Person(T t) : vtable_( &amp;amp;vtable_for&amp;lt;T&amp;gt; ), p(new T{t}) {}
 private:
  vtable* vtable_;
  void* p;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来，这个类就可以很棒了。你可以像下面这么定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;std::vector&amp;lt;Person&amp;gt; persons;

persons.push_back(Student{});
persons.push_back(Teacher{});
...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用起来的时候，一切都看起来和 golang 的那个版本差不多了呢。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;C%2B%2B14#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF&quot;&gt;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;C%2B%2B14#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>Compile Time Reflection in C++11</title>
            <pubDate>Sun, 15 Apr 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/compile-time-reflection/</link>
            <guid>https://twistoy.com/posts/compile-time-reflection/</guid>
            <description>&lt;h1 id=&quot;gu-shi-bei-jing&quot;&gt;故事背景&lt;&#x2F;h1&gt;
&lt;p&gt;故事发生在遥远的我在使用C++来处理JSON和对象绑定的时候，我厌倦了写这样的代码:&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class Foo {
  int bar1;
  int bar2;
  int bar3;
  std::string bar4;
  int bar5;
  std::string ToJsonString();
};
std::string Foo::ToJsonString() {
  Document doc;
  doc.SetObject();
  doc.AddMember(&amp;quot;bar1&amp;quot;, Value(bar1), doc.GetAllocator());
  doc.AddMember(&amp;quot;bar2&amp;quot;, Value(bar2), doc.GetAllocator());
  doc.AddMember(&amp;quot;bar3&amp;quot;, Value(bar3), doc.GetAllocator());
  doc.AddMember(&amp;quot;bar4&amp;quot;, Value(bar4), doc.GetAllocator());
  doc.AddMember(&amp;quot;bar5&amp;quot;, Value(bar5), doc.GetAllocator());
  ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样的代码又复杂又容易出错，所以我就在考虑一种可以自动的将这些东西都完成好的绑定方法。所以就有了文章写的内容。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yu-bei-bu-fen&quot;&gt;预备部分&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;mo-ban-lei&quot;&gt;模板类&lt;&#x2F;h2&gt;
&lt;p&gt;我们需要一个可以在编译时期被构造的字符串类，用于保存我们需要反射的类的类名和成员名。在C++17之后，我们可以使用标准库中提供的&lt;code&gt;std::string_view&lt;&#x2F;code&gt;来实现，但是在C++11中，我们没有这样的实现，就只能用&lt;code&gt;constexpr&lt;&#x2F;code&gt;的构造函数来实现一个我们自己的&lt;code&gt;std::string_view&lt;&#x2F;code&gt;类。
这部分在C++11中的实现可以参考我在另一篇文章中的实现。&lt;a href=&quot;https:&#x2F;&#x2F;twistoy.com&#x2F;post&#x2F;compile-time-const-array&quot;&gt;https:&#x2F;&#x2F;twistoy.com&#x2F;post&#x2F;compile-time-const-array&lt;&#x2F;a&gt;
这里给出一个简单的实现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class ConstString {
 public:
  template&amp;lt;uint32_t N&amp;gt;
  constexpr ConstString(const char (&amp;amp;arr)[N]) : begin_(arr), size_(N-1) {
    static_assert(N &amp;gt;= 1, &amp;quot;const string literal should not be empty&amp;quot;);
  }

  constexpr ConstString(const char* buf, uint32_t len)
    : begin_(buf), size_(len) {}

  constexpr char operator[](uint32_t i) const {
    return begin_[RequiresInRange(i, size_)];
  }

  constexpr const char* Begin() const {
    return begin_;
  }

  constexpr const char* End() const {
    return begin_ + size_;
  }

  constexpr uint32_t Size() const {
    return size_;
  }

  constexpr ConstString SubString(int pos, int len) const {
    return RequiresInRange(pos, size_), RequiresInRange(pos + len, size_),
           ConstString(begin_ + pos, len);
  }

 private:
  const char* const begin_;
  uint32_t size_;
};

constexpr bool operator==(ConstString a, ConstString b) {
  return a.Size() != b.Size() ? false
       : StringEqual(a.Begin(), b.Begin(), a.Size());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个实现提供了在字符串上的几个基本操作，后面的实现中可以根据自己的需要扩展。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hong-macro&quot;&gt;宏（macro）&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;hong-can-shu-ge-shu&quot;&gt;宏参数个数&lt;&#x2F;h3&gt;
&lt;p&gt;我们都知道，在C++11中提供了变长参数模板，可以让我们接受任意个任意类型的参数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename... Args&amp;gt;
void fuck(Args... args);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还有技巧可以帮助我们写出类型处理正确的、零开销的完美转发；有扩展的用法&lt;code&gt;sizeof...(Args)&lt;&#x2F;code&gt;来帮助我们获得参数包中参数的个数。
但是，如果我们想得到一个宏的变长参数包中参数的个数呢？有什么宏展开的技巧可以帮助我们做到这一点呢。答案显然是有的，我们用两个宏来配合我们做到这一点：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __RSEQ_N() 5, 4, 3, 2, 1, 0
#define __ARG_N(_1, _2, _3, _4, _5, N, ...) N
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的宏考虑其展开的过程：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;__ARG_N(a, b, c, __RSEQ_N())  &amp;#x2F;&amp;#x2F; 1：调用 
__ARG_N(a, b, c, 5, 4, 3, 2, 1, 0)  &amp;#x2F;&amp;#x2F; 2：展开1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;考虑展开后的形式：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;   __ARG_N( a,  b,  c,  5,  4, 3, 2, 1, 0)
&amp;#x2F;&amp;#x2F; __ARG_N(_1, _2, _3, _4, _5, N, ...) N
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们可以明显的得到&lt;code&gt;__ARG_N&lt;&#x2F;code&gt;这个宏在这种情况下展开的结果为&lt;code&gt;3&lt;&#x2F;code&gt;。我们再对这个宏进行简单的包装，就得到了一个易用的获得宏参数个数的宏。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __GET_ARG_COUNT_INNER(...) __ARG_N(__VA_ARGS__)
#define __GET_ARG_COUNT(...) __GET_ARG_COUNT_INNER(__VA_ARGS__, __RSEQ_N())
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对这个宏进行一些简单的测试：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;assert(__GET_ARG_COUNT(a,), 1);
assert(__GET_ARG_COUNT(a, b), 2);
assert(__GET_ARG_COUNT(a, b, c), 3);
assert(__GET_ARG_COUNT(a, b, c, d), 4);
assert(__GET_ARG_COUNT(a, b, c, d, e), 5);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过扩展宏&lt;code&gt;__RSEQ_N()&lt;&#x2F;code&gt;和宏&lt;code&gt;__ARG_N&lt;&#x2F;code&gt;来扩展其所支持的参数个数。简单的增加宏里的参数个数和数值即可。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gou-zao-zi-fu-chuan-xu-lie&quot;&gt;构造字符串序列&lt;&#x2F;h3&gt;
&lt;p&gt;我们都知道，在宏里面可以通过使用&lt;code&gt;#&lt;&#x2F;code&gt;来将一个宏参数用引号来括起来，形成字符串的形式。那么利用这个特性，我们就可以得到一个参数的字符串形式和我们上面完成的常量字符串对象。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __ADD_VIEW(str) ConstString(#str)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;并且通过宏的递归来实现生成一个常量字符串对象的序列：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __CONST_STR_1(str, ...) __ADD_VIEW(str)
#define __CONST_STR_2(str, ...) __ADD_VIEW(str), __CONST_STR_1(__VA_ARGS__)
#define __CONST_STR_3(str, ...) __ADD_VIEW(str), __CONST_STR_2(__VA_ARGS__)
...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;以此类推可以得到你想要的个数的形式。【如果你在使用VIM的话，这里的代码可以简单的使用VIM的宏功能来完成。（使用q来录制一个宏，C-A来自增当前位置的数字）。VIM最棒啦。我就是这么完成的UoU】
上面的宏，将被展开成这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; __CONST_STR_3(a, b, c)
ConstString(&amp;quot;a&amp;quot;), ConstString(&amp;quot;b&amp;quot;), ConstString(&amp;quot;c&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;jiang-can-shu-xu-lie-zhuan-cheng-zi-fu-chuan-xu-lie&quot;&gt;将参数序列转成字符串序列&lt;&#x2F;h2&gt;
&lt;p&gt;先搞一个简单的宏把两个名字连起来成为一个名字：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __MACRO_CONCAT(m1, m2) __MACRO_CONCAT_IMPL(m1, m2)
#define __MACRO_CONCAT_IMPL(m1, m2) m1##_##m2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后结合我们上面完成的两个宏，就可以啦：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __MAKE_STR_LIST(...) __MACRO_CONCAT(__CONST_STR, __GET_ARG_COUNT(__VA_ARGS__))(__VA_ARGS)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;将&lt;code&gt;__CONST_STR&lt;&#x2F;code&gt;这个名字和参数个数连起来，就是其在我们上面实现的第二个宏的名字，比如：&lt;code&gt;__CONST_STR_1&lt;&#x2F;code&gt;、&lt;code&gt;__CONST_STR_2&lt;&#x2F;code&gt;等等。然后再调用这个宏即可。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jiang-yi-ge-cao-zuo-xie-ru-suo-you-de-hong-can-shu&quot;&gt;将一个操作写入所有的宏参数&lt;&#x2F;h2&gt;
&lt;p&gt;在这里使用类似字符串转换那里的技巧，可以很容易的得到一个宏：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __MAKE_ARG_LIST_1(op, arg, ...) op(arg)
#define __MAKE_ARG_LIST_2(op, arg, ...) op(arg), __MAKE_ARG_LIST_1(op, __VA_ARGS__)
...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的宏被使用时，将这样被展开：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __FIELD(t) t
&amp;#x2F;&amp;#x2F; __MAKE_ARG_LIST_3(&amp;amp;Name::__FIELD, a, b, c)
&amp;amp;Name::a, &amp;amp;Name::b, &amp;amp;Name::c
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;shi-yong-yi-ge-lei-lai-bao-cun-zhe-xie-hong-xin-xi&quot;&gt;使用一个类来保存这些宏信息&lt;&#x2F;h1&gt;
&lt;p&gt;在这里我希望构造一个类似这样的结构体来保存一个类的成员的宏信息：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct Name {
  char* rname;
};

struct __reflect_struct_Name {
  using size_type = std::integral_constant&amp;lt;size_t, 1&amp;gt;;
  constexpr static ConstString Name() {
    return ConstString(&amp;quot;Name&amp;quot;);
  }
  constexpr static size_t Value() {
    return size_type::value;
  }
  constexpr static std::array&amp;lt;ConstString, size_type::value&amp;gt; MembersName() {
    return std::array&amp;lt;ConstString, 1&amp;gt;{{ ConstString(&amp;quot;rname&amp;quot;) }};
  }
  constexpr decltype(std::make_tuple(&amp;amp;Name::rname)) static MembersPointer() {
    return std::make_tuple(&amp;amp;Name::rname);
  }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;观察我们上面的几个宏，可以显然得到这样的一种写法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#define __MAKE_REFLECT_CLASS(StructName, ...) \
  struct __reflect_struct_##StructName { \
    using size_type = std::integral_constant&amp;lt;size_t, __GET_ARG_COUNT(__VA_ARGS__)&amp;gt;; \
    constexpr static ConstString Name() { \
      return ConstString(#StructName); \
    } \
    constexpr static size_t Value() { \
      return size_type::value; \
    } \
    constexpr static std::array&amp;lt;ConstString, size_type::value&amp;gt; MembersName() { \
      return std::array&amp;lt;ConstString, size_type::value&amp;gt;{{ \
        __MACRO_CONCAT(__CONST_STR, __GET_ARG_COUNT(__VA_ARGS__))(__VA_ARGS__) \
      }}; \
    } \
    constexpr static decltype(std::make_tuple()) static MembersPointer() {
      return std::make_tuple( \
        __MACRO_CONCAT(__MAKE_ARG_LIST, &amp;amp;StructName::__FIELD, __VA_ARGS__) \
      ); \
    } \
  };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的这个宏可以帮助我们构造一个结构体，在结构体里的分别用&lt;code&gt;Name()&lt;&#x2F;code&gt;方法来返回其保存的元信息类型名，用&lt;code&gt;MembersName()&lt;&#x2F;code&gt;返回保存类型的所有成员名，用&lt;code&gt;MembersPointer()&lt;&#x2F;code&gt;返回保存类型的所有成员指针。
然后利用函数的重载来返回这个结构体:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;__reflect_struct_##StructName __reflect_structs(StructName const&amp;amp;) { \
  return __reflect_struct##StructName{}; \
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;shi-yong-mo-ban-han-shu-lai-huo-qu-zhe-xie-yuan-xin-xi&quot;&gt;使用模板函数来获取这些元信息&lt;&#x2F;h1&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
constexpr const ConstString GetName() {
  return decltype(__reflect_structs(std::declval&amp;lt;T&amp;gt;()))::Name();
}

template&amp;lt;typename T&amp;gt;
constexpr const ConstString GetName(size_t i) {
  return decltype(__reflect_structs(std::declval&amp;lt;T&amp;gt;)))::MembersName()[i];
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;后面的思想基本就都和这个类似，利用模板和函数重载来获取这些类型的元信息。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;jie-he-qi-ta-hong-shi-yong&quot;&gt;结合其他宏使用&lt;&#x2F;h1&gt;
&lt;p&gt;在使用这种操作的时候，我们需要使用一个宏来构造我们上面提到的所有元信息，这个应该是一个没有办法的事情了。为了这个功能这些多出来的代码，我也是可以接受的。
当然如果这个类型本来就是使用宏构造出来的话，就可以把这两个宏很舒服的结合在一起啦~所以我也推荐你这么用哦。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>C++11内存模型</title>
            <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/cpp11-memory-model/</link>
            <guid>https://twistoy.com/posts/cpp11-memory-model/</guid>
            <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;&#x2F;&#x2F; cpp concurrency in action 里的例子&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void undefined_behaviour_with_double_checked_locking() {
  if (!resource_ptr) { &amp;#x2F;&amp;#x2F; 1
    std::lock_guard&amp;lt;std::mutex&amp;gt; lk(resource_mutex);
    if (!resource_ptr) { &amp;#x2F;&amp;#x2F; 2
      resource_ptr.reset(new some_resource); &amp;#x2F;&amp;#x2F; 3
    }
  }
  resource_ptr-&amp;gt;do_something(); &amp;#x2F;&amp;#x2F; 4
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;在 &lt;em&gt;C++ Concurrency in Action&lt;&#x2F;em&gt;  中提到过一段很有意思的代码，这段代码存在潜在的条件竞争。未被锁保护的操作①，没有与另一个线程中被锁保护了的操作③进行同步，在这样的情况下就有可能产生条件竞争。这个操作不光会覆盖指针本身，还有会影响到其指向的对象。所以在后面的操作④就有可能会导致不正确的结果。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;out-of-order-process&quot;&gt;Out-of-order process&lt;&#x2F;h1&gt;
&lt;p&gt;让我们从一个稍微简单一点的例子聊起。考虑现在我们的程序有两个线程，他们持有共同的变量 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt;，其中 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 的初始值都是0，两个线程分别执行了这样的代码：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程1&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;b = 1;  &amp;#x2F;&amp;#x2F; 1
a = 1;   &amp;#x2F;&amp;#x2F; 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;线程2：&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a = 0, b = 0;
while (a == 0);
assert(b == 1);  &amp;#x2F;&amp;#x2F; 3
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这个例子里面，我们可以保证每次在位置①的断言都可以成功么？
显然我们没有办法预期位置③的断言每次都成功，因为我们没法保证操作①每次都在操作②之前完成。
这里有两个主要的原因：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;编译器可能会对没有依赖的语句进行优化，重排他们的执行顺序&lt;&#x2F;li&gt;
&lt;li&gt;CPU在执行字节码的时候，会对没有依赖关系的语句重排执行顺序
显然在上面的例子中，操作②就有可能被重排到操作①之前，在这种情况下我们在线程2就没法观测到正确的结果，从而导致位置③的断言失败。
考虑这样的一种情况：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;asm&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;L1: LDR R1, [R0]
L2: ADD R2, R1, R1
L3: ADD R4, R3, R3
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在按序执行的情况下，我们预期的顺序应该是：
&lt;code&gt;L1&lt;&#x2F;code&gt;-&amp;gt;&lt;code&gt;L2&lt;&#x2F;code&gt;-&amp;gt;&lt;code&gt;L3&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;然而我们可以很容易的发现，语句3 和语句1 是没有依赖关系的，而语句2可以会依赖于语句1的执行结果，所以CPU经过乱序，并且可能将这三个操作发送到两个不同的CPU单元上，并且得到另一种执行顺序：
&lt;code&gt;L1&lt;&#x2F;code&gt;-&amp;gt;&lt;code&gt;L2&lt;&#x2F;code&gt;
&lt;code&gt;L3&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;再就是现在的多核CPU带来的可能缓存不一致的问题，在一个CPU核心上后写入的数据在其他的地方未必是后写入的。所以就会出现我们最上面的例子中，我们尝试使用一个标记位用来标记其他的数据是否已经准备好了，然后我们可能会在另一个核心上来判断这个标志位来决定所需要的数据是否已经准备就位。这样的操作的风险就在于，可能在被乱序执行的情况下，标志位被先写入了，然后才开始准备数据，这样在另一个核心观测就会得到不一样的、错误的结果。所以我们就必须在我们的代码中做出一些保护机制。&lt;&#x2F;p&gt;
&lt;p&gt;在C++11之前，我们有一种普遍的用法，就是内存屏障。而在C++11中，我们有了另一个选择，就是&lt;code&gt;atomic&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;atomic-in-c-11&quot;&gt;&lt;code&gt;atomic&lt;&#x2F;code&gt; in C++11&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;atomic&lt;&#x2F;code&gt; 是在 C++11 中被加入了标准库的，这个库提供了针对于布尔、整数和指针类型的原子操作。原子操作意味着不可分的最小执行单位，一个原子操作要么成功，要么失败，是不会被线程的切换多打断的执行片段。对于在不同的线程上访问原子类型上操作是well-defined的，是不具有数据竞争的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mo-ban-lei-atomic&quot;&gt;模板类 &lt;code&gt;atomic&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;模板类 &lt;code&gt;atomic&lt;&#x2F;code&gt; 是整个库的核心，标准库中提供了针对布尔类型、整数类型和指针类型的特化，除此之外的情况请保证用于特化模板的类型时一个平凡的（trivial）类型。
在原子类上，显然有两个基础操作：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
void store(T, memory_order = memory_order_seq_cst) noexcept;
T load(memory_order = memory_order_seq_cst) const volatile noexcept;
T load(memory_order = memory_order_seq_cst) const noexcept;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用于更新原子对象当前值的 &lt;code&gt;store&lt;&#x2F;code&gt; 方法和读取原子对象当前值的 &lt;code&gt;load&lt;&#x2F;code&gt; 方法。对于 &lt;code&gt;store&lt;&#x2F;code&gt; 方法，指定的内存顺序必须是 &lt;code&gt;std::memory_order_relaxed&lt;&#x2F;code&gt;、&lt;code&gt;std::memory_order_release&lt;&#x2F;code&gt; 或 &lt;code&gt;std::memory_order_seq_cst&lt;&#x2F;code&gt;其中的一个，指定为其他的内存顺序都是未定义行为；对于&lt;code&gt;load&lt;&#x2F;code&gt;方法，指定的内存顺序必须是 &lt;code&gt;std::memory_order_relaxed&lt;&#x2F;code&gt;、&lt;code&gt;std::memory_order_consume&lt;&#x2F;code&gt;、&lt;code&gt;std::memory_order_acquire&lt;&#x2F;code&gt;或&lt;code&gt;std::memory_order_seq_cst&lt;&#x2F;code&gt;其中的一个，其他的内存顺序同样都是未定义行为。
还有一个操作，原子的以新值替换旧值并返回旧值。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;T exchange( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept;
T exchange( T desired, std::memory_order order = std::memory_order_seq_cst ) volatile noexcept;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是一个读-修改-写的操作，类似的还有&lt;code&gt;test-and-set&lt;&#x2F;code&gt;，&lt;code&gt;fetch-and-add&lt;&#x2F;code&gt;，&lt;code&gt;compare-and-swap&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;memory-model&quot;&gt;Memory Model&lt;&#x2F;h1&gt;
&lt;p&gt;C++中提供了六种内存模型，其中的一些通常会成对出现。&lt;&#x2F;p&gt;
&lt;p&gt;memory_order_relaxed：对操作的上下文没有要求，仅要求当前操作的原子性
memory_order_consume：当前的加载操作，在其影响的内存位置上进行 &lt;em&gt;消费&lt;&#x2F;em&gt;：当前线程中依赖于该值读或写的操作不能被重排到该操作之前；在其他线程中，该值所依赖的变量的写入都可以被当前线程正确的观测到
memory_order_acquire：当前的加载操作，在其影响的内存位置上进行 &lt;em&gt;获取&lt;&#x2F;em&gt;：当前线程的读或写都不能重排到该操作之前；在其他线程中的所有位于该操作之前的读或写都可以被当前线程正确的观测到
memory_order_release：当前的存储操作，在其影响的内存位置上进行 &lt;em&gt;释放&lt;&#x2F;em&gt;：当前线程的读或写都不能重排到该操作之前；在其他线程中的所有位于该操作之前的写都可以被当前线程正确的观测到
memory_order_acq_rel：当前的加载或是存储操作，既在其影响的内存位置上进行 &lt;em&gt;获取&lt;&#x2F;em&gt; 也进行 &lt;em&gt;释放&lt;&#x2F;em&gt;
memory_order_seq_cst：当前的加载操作在其影响的内存位置进行 &lt;em&gt;获取&lt;&#x2F;em&gt;，存储操作进行 &lt;em&gt;释放&lt;&#x2F;em&gt;，读-修改-写操作进行 &lt;em&gt;获取&lt;&#x2F;em&gt; 和 &lt;em&gt;释放&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;memory-order-relaxed&quot;&gt;&lt;code&gt;memory_order_relaxed&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在这个内存模型中，不要求操作在访问同样内存时候的操作顺序，只保证了原子性和修改的一致性。考虑下面的例子，对于初值为0的两个原子量&lt;code&gt;x&lt;&#x2F;code&gt;和&lt;code&gt;y&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; thread 1
r1 = y.load(memory_order_relaxed); &amp;#x2F;&amp;#x2F; 1
x.store(r1, memory_order_relaxed); &amp;#x2F;&amp;#x2F; 2
&amp;#x2F;&amp;#x2F; thread 2
r2 = x.load(memory_order_relaxed); &amp;#x2F;&amp;#x2F; 3 
y.store(42, memory_order_relaxed); &amp;#x2F;&amp;#x2F; 4
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里是允许出现&lt;code&gt;x&lt;&#x2F;code&gt;和&lt;code&gt;y&lt;&#x2F;code&gt;同时等于42的情况，因为我们即使知道操作①先于操作②，操作③先于操作④；但是我们没有约束操作④不能优先出现于操作①。所以我们可以观测到任何可能的结果。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;memory-order-acquire-memory-order-consume&quot;&gt;&lt;code&gt;memory_order_acquire&lt;&#x2F;code&gt; &amp;amp;&amp;amp; &lt;code&gt;memory_order_consume&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在这个顺序模型中，存储操作 &lt;em&gt;释放&lt;&#x2F;em&gt; ；加载操作 &lt;em&gt;消费&lt;&#x2F;em&gt; 。如果线程1中的存储操作使用了 &lt;em&gt;释放&lt;&#x2F;em&gt; 标记；而线程2中的加载操作使用了 &lt;em&gt;消费&lt;&#x2F;em&gt; 标记。那么在线程1中的存储操作所依赖的所有内存写入都对在线程2中都可以被正确的观测到。这种同步仅仅建立在存储和加载的两个线程之间，对其他线程无效。&lt;&#x2F;p&gt;
&lt;p&gt;可以使用&lt;code&gt;std::kill_dependency&lt;&#x2F;code&gt;来消除从带有消费标记的加载操作开始的依赖树，不会讲依赖带入返回值。这个操作可以避免依赖链在离开函数作用域时，不必要的&lt;code&gt;memory_order_acquire&lt;&#x2F;code&gt;栅栏。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;memory-order-acquire-memory-order-release&quot;&gt;&lt;code&gt;memory_order_acquire&lt;&#x2F;code&gt; &amp;amp;&amp;amp; &lt;code&gt;memory_order_release&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在这个顺序模型中，存储操作 &lt;em&gt;释放&lt;&#x2F;em&gt;；加载操作 &lt;em&gt;获取&lt;&#x2F;em&gt;。如果线程1中的存储操作使用了 &lt;em&gt;释放&lt;&#x2F;em&gt; 标记；而线程2中的加载操作使用了 &lt;em&gt;获取&lt;&#x2F;em&gt; 标记。那么在线程1中，所以先于存储操作的内存写入在线程2中都可以被正确的观测到。这种同步仅建立在存储和加载的两个线程之间，对其他的线程无效。
所以考虑最开始的代码，如果我们将变量&lt;code&gt;a&lt;&#x2F;code&gt;改为&lt;code&gt;atomic&amp;lt;int&amp;gt;&lt;&#x2F;code&gt;，并且使用 release-acquire 的内存模型，就可以保证断言③的绝对正确。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;atomic&amp;lt;int&amp;gt; a;
int b;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;线程1&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;b = 1;  &amp;#x2F;&amp;#x2F; 1
a.store(1, std::memory_order_release);  &amp;#x2F;&amp;#x2F; 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;线程2：&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a = 0, b = 0;
while (a.load(std::memory_order_acquire) == 0);
assert(b == 1);  &amp;#x2F;&amp;#x2F; 3
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;memory-order-seq-cst&quot;&gt;&lt;code&gt;memory_order_seq_cst&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;除了在进行 &lt;em&gt;释放&lt;&#x2F;em&gt; 和 &lt;em&gt;获取&lt;&#x2F;em&gt; 操作外，还会的所有持有此标记的操作建立一个单独全序（single total modification order）。这个表示每个标记了&lt;em&gt;memory_order_seq_cst&lt;&#x2F;em&gt;的操作，都可以观测到在其之前发生的标记有&lt;em&gt;memory_order_seq_cst&lt;&#x2F;em&gt;；并且可能观测到在其之前的，未标记为&lt;code&gt;memory_order_seq_cst&lt;&#x2F;code&gt;的操作。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;thread&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;cassert&amp;gt;
 
std::atomic&amp;lt;bool&amp;gt; x = {false};
std::atomic&amp;lt;bool&amp;gt; y = {false};
std::atomic&amp;lt;int&amp;gt; z = {0};
 
void write_x() {
    x.store(true, std::memory_order_seq_cst);
}
 
void write_y() {
    y.store(true, std::memory_order_seq_cst);
}
 
void read_x_then_y() {
    while (!x.load(std::memory_order_seq_cst));
    if (y.load(std::memory_order_seq_cst)) {
        ++z;
    }
}
 
void read_y_then_x() {
    while (!y.load(std::memory_order_seq_cst));
    if (x.load(std::memory_order_seq_cst)) {
        ++z;
    }
}
 
int main(){
    std::thread a(write_x);
    std::thread b(write_y);
    std::thread c(read_x_then_y);
    std::thread d(read_y_then_x);
    a.join(); b.join(); c.join(); d.join();
    assert(z.load() != 0);  &amp;#x2F;&amp;#x2F; 1
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面例子中操作①处的断言绝不可能失败。&lt;&#x2F;p&gt;
&lt;p&gt;使用此序列顺序在多核模式下要求完全内存栅栏的CPU指令，这可能会成为性能的瓶颈，因为它将其受影响的内存的影响传播到了每个核心。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>在C++17中的部分新特性</title>
            <pubDate>Sun, 25 Feb 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/changes-in-cpp-17/</link>
            <guid>https://twistoy.com/posts/changes-in-cpp-17/</guid>
            <description>&lt;p&gt;C++17已经发布了有一些时候，并且很多的编译器已经完成了对C++17的支持，那对于C++17中的新特性，我也好奇的玩了一些，其中的几个新特性特别吸引我的注意。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;if-init&quot;&gt;if-init&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;grammar&quot;&gt;Grammar&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;if&lt;&#x2F;strong&gt; &lt;strong&gt;(&lt;&#x2F;strong&gt; &lt;em&gt;init-statement&lt;&#x2F;em&gt; &lt;em&gt;condition&lt;&#x2F;em&gt; &lt;strong&gt;)&lt;&#x2F;strong&gt;
&lt;em&gt;init-statement&lt;&#x2F;em&gt; 可以是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;表达式语句（可以是空语句，仅&lt;code&gt;;&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;声明语句&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;thinking&quot;&gt;Thinking&lt;&#x2F;h2&gt;
&lt;p&gt;if-init 这个 feature 尝试着让我们的代码更可读和干净，并且可以帮助我们更好的控制对象的生命周期。在从前的 &lt;code&gt;if&lt;&#x2F;code&gt; 语句中，我们经常会做类似的事情：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void foo(int a) {
    auto iter = a_map.find(a);
    if (iter != a_map.end()) {
        &amp;#x2F;&amp;#x2F; do_something
    } else {
        &amp;#x2F;&amp;#x2F; do_something_else
    }
    &amp;#x2F;&amp;#x2F; do_something_next
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个叫做&lt;code&gt;iter&lt;&#x2F;code&gt;的变量其实我们除了用于这个&lt;code&gt;if&lt;&#x2F;code&gt;判断和语句块中的操作之外，我们可能再也不会用到它。它的生命周期其实无形的被延长到了整个函数的结束。就像我们在&lt;code&gt;for&lt;&#x2F;code&gt;语句中做的一样，我们为什么不把这个对象的生命周期限定在一个&lt;code&gt;if&lt;&#x2F;code&gt;语句块中呢？所以就有了 if-init 这个 feature。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void foo(int a) {
    if (auto iter = a_map.find(a); iter != a_map.end()) {
        &amp;#x2F;&amp;#x2F; do_something
    } else {
        &amp;#x2F;&amp;#x2F; do_something_else
    }
    &amp;#x2F;&amp;#x2F; do_something_next
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的写法就像在&lt;code&gt;for&lt;&#x2F;code&gt;语句中的那样自然，我们在一个&lt;code&gt;if&lt;&#x2F;code&gt;中初始化一个对象，并且使用它，当离开&lt;code&gt;if&lt;&#x2F;code&gt;语句的时候，这个对象就被销毁了。
一些更多的用法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&amp;#x2F;&amp;#x2F; with temporary read buffer
if (char buf[64]; std::fgets(buf, 64, stdin)) { m[0] += buf; }

&amp;#x2F;&amp;#x2F; with lock
if (std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mx); shared_flag) { unsafe_ping(); shared_flag = false; }

&amp;#x2F;&amp;#x2F; with temporary input param
if (int s; int count = ReadBytesWithSignal(&amp;amp;s)) { publish(count); raise(s); }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;structured-bingds&quot;&gt;structured-bingds&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;grammar-1&quot;&gt;Grammar&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;attr&lt;&#x2F;em&gt;(optional) &lt;em&gt;cv-auto&lt;&#x2F;em&gt; &lt;em&gt;ref-operator&lt;&#x2F;em&gt;(optional) &lt;strong&gt;[&lt;&#x2F;strong&gt; &lt;em&gt;indentifier-list&lt;&#x2F;em&gt; &lt;strong&gt;] =&lt;&#x2F;strong&gt; &lt;em&gt;expression&lt;&#x2F;em&gt; &lt;strong&gt;;&lt;&#x2F;strong&gt;
&lt;em&gt;attr&lt;&#x2F;em&gt;(optional) &lt;em&gt;cv-auto&lt;&#x2F;em&gt; &lt;em&gt;ref-operator&lt;&#x2F;em&gt;(optional) &lt;strong&gt;[&lt;&#x2F;strong&gt; &lt;em&gt;indentifier-list&lt;&#x2F;em&gt; &lt;strong&gt;] {&lt;&#x2F;strong&gt; &lt;em&gt;expression&lt;&#x2F;em&gt; &lt;strong&gt;};&lt;&#x2F;strong&gt;
&lt;em&gt;attr&lt;&#x2F;em&gt;(optional) &lt;em&gt;cv-auto&lt;&#x2F;em&gt; &lt;em&gt;ref-operator&lt;&#x2F;em&gt;(optional) &lt;strong&gt;[&lt;&#x2F;strong&gt; &lt;em&gt;indentifier-list&lt;&#x2F;em&gt; &lt;strong&gt;] (&lt;&#x2F;strong&gt; &lt;em&gt;expression&lt;&#x2F;em&gt; &lt;strong&gt;);&lt;&#x2F;strong&gt;
这里在绑定时候的基本规则是：（这里用 &lt;em&gt;Expression&lt;&#x2F;em&gt; 来表示 &lt;em&gt;expression&lt;&#x2F;em&gt; 表达式的类型）&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果 &lt;em&gt;Expression&lt;&#x2F;em&gt; 是数组类型，则一次绑定到数组元素&lt;&#x2F;li&gt;
&lt;li&gt;如果 &lt;em&gt;Expression&lt;&#x2F;em&gt; 是非联合体类型，且&lt;code&gt;std::tuple_size&amp;lt;Expression&amp;gt;&lt;&#x2F;code&gt;是完整类型，则使用类tuple绑定&lt;&#x2F;li&gt;
&lt;li&gt;如果 &lt;em&gt;Expression&lt;&#x2F;em&gt; 是非联合体类型，且&lt;code&gt;std::tuple_size&amp;lt;Expression&amp;gt;&lt;&#x2F;code&gt;不是完整类型，则以此绑定到类的公开数据成员&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;case-1-binding-an-array&quot;&gt;Case 1：Binding an array&lt;&#x2F;h3&gt;
&lt;p&gt;每个 &lt;em&gt;indentifier-list&lt;&#x2F;em&gt; 中的标识符绑定到数组的每一个元素，标识符数量必须和数组大小一致。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a[2] = {1,2};
 
auto [x,y] = a;
auto&amp;amp; [xr, yr] = a;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;case-2-binding-a-tuple-like-type&quot;&gt;Case 2: Binding a tuple-like type&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;std::tuple_size&amp;lt;Expression&amp;gt;::value&lt;&#x2F;code&gt;必须是一个合法的编译时期常量，并且标识符的数量和&lt;code&gt;std::tuple_size&amp;lt;Expression&amp;gt;::value&lt;&#x2F;code&gt;的值相等。
在 &lt;em&gt;ref-operator&lt;&#x2F;em&gt; 为&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;或者&lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt;时：
对于每一个标识符，若其对应的初始化表达式是左值，则为左值引用；若为右值则为右值引用。
每个标识符对应的初始化表达式使用如下规则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;expression.get&amp;lt;i&amp;gt;()&lt;&#x2F;code&gt;，表达式包含了一个如此的声明&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;get&amp;lt;i&amp;gt;(expression)&lt;&#x2F;code&gt;，仅按照 ADL&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#ADL&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 规则查找对应的声明（在这种使用中，如果 &lt;em&gt;expression&lt;&#x2F;em&gt; 对象是一个左值，那么传入的参数也为左值；如果 &lt;em&gt;expression&lt;&#x2F;em&gt; 对象是一个右值，那么传入的对象也为右值）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;float x{};
char  y{};
int   z{};
 
const auto&amp;amp; [a,b,c] = std::tuple&amp;lt;float&amp;amp;,char&amp;amp;&amp;amp;,int&amp;gt;(x,std::move(y),z);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;case-3-binding-to-public-data-members&quot;&gt;Case 3: Binding to public data members&lt;&#x2F;h3&gt;
&lt;p&gt;每个 &lt;em&gt;Expression&lt;&#x2F;em&gt; 的非静态公开成员变量都会被依次绑定，并且标识符个数要和非静态公开成员变量个数相等。
所以的非静态公开成员都应该是无歧义的，且不能有任何的匿名联合体成员。
标识符最后的类型的 CV限定符会合并其类成员变量的类型中的CV限定符和声明中的的CV限定符。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct S {
    int x1 : 2;
    volatile double y1;
};
S f();
 
const auto [x, y] = f();
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;thinking-1&quot;&gt;Thinking&lt;&#x2F;h2&gt;
&lt;p&gt;structured-binding 带给我们在书写上方便的同时也带来了相应的更大的心智负担，它让我们不仅要关注一个变量的类型，我们还要关注它所指向的对象的类型。因为在这里创建的不是一个引用，也不是对象的拷贝，而是一个既存对象的别名。
比如下面这个例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;BarBar foo(Bar bar) {
    &amp;#x2F;&amp;#x2F; do_something
    return bar.bar;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果我们如此明显的书写的话，我们都知道，返回一个 sub-object 是不能触发 RVO&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#RVO&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; 的。那么我们如果用了结构化绑定的方式之后呢？&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;BarBar foo(Bar bar) {
    auto [..., b, ...] = bar;
    &amp;#x2F;&amp;#x2F; do_something
    return b;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很遗憾的是，这里依旧不能触发 RVO 的，因为这里的&lt;code&gt;b&lt;&#x2F;code&gt;是一个对象的别名，既不是引用也不是什么别的，它依旧会被认为是一个 sub-object。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;if-init-with-structured-bindings&quot;&gt;if-init with structured-bindings&lt;&#x2F;h1&gt;
&lt;p&gt;将 if-init 和 structured-bindings 可以帮助我们在很多地方缩减我们的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;if (auto [iter, inserted] = m.insert({&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;}); inserted) {
    &amp;#x2F;&amp;#x2F; do_something
} else {
    &amp;#x2F;&amp;#x2F; do_other_things
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;if-constexpr&quot;&gt;if-constexpr&lt;&#x2F;h1&gt;
&lt;p&gt;if-constexpr 可以帮助我们简化原本很多需要用 SFINAE 来实现的代码，用来模板中使用哪一部分的实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sample-1&quot;&gt;Sample 1&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;before-c-17&quot;&gt;Before C++17&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;type_traits&amp;gt;

template&amp;lt;typename T&amp;gt;
auto get_value_impl(T t, std::false_type) {
    return t;
}
template&amp;lt;typename T&amp;gt;
auto get_value_impl(T t, std::true_type) {
    return *t;
}
template&amp;lt;typename T&amp;gt;
auto get_value(T t) {
    return get_value_impl(t, std::is_pointer&amp;lt;T&amp;gt;());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;after-c-17&quot;&gt;After C++17&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;typename T&amp;gt;
auto get_value(T t) {
    if constexpr (std::is_pointer_v&amp;lt;T&amp;gt;)
        return *t;
    else
        return t; 
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;sample-2&quot;&gt;Sample 2&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;before-c-17-1&quot;&gt;Before C++17&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;int  N&amp;gt;
constexpr int fibonacci() {return fibonacci&amp;lt;N-1&amp;gt;() + fibonacci&amp;lt;N-2&amp;gt;(); }
template&amp;lt;&amp;gt;
constexpr int fibonacci&amp;lt;1&amp;gt;() { return 1; }
template&amp;lt;&amp;gt;
constexpr int fibonacci&amp;lt;0&amp;gt;() { return 0; }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;after-c-17-1&quot;&gt;After C++17&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;int N&amp;gt;
constexpr int fibonacci()
{
    if constexpr (N&amp;gt;=2)
        return fibonacci&amp;lt;N-1&amp;gt;() + fibonacci&amp;lt;N-2&amp;gt;();
    else
        return N;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;if-constexpr 的出现我感觉不是为了解决什么特别的问题，而是为了简化我们的代码，让我们在写的时候可以更自然，更符合直觉。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fold-expression&quot;&gt;fold expression&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;grammar-2&quot;&gt;Grammar&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;(&lt;&#x2F;strong&gt; &lt;em&gt;pack&lt;&#x2F;em&gt; &lt;em&gt;op&lt;&#x2F;em&gt; &lt;strong&gt;... )&lt;&#x2F;strong&gt;
&lt;strong&gt;( ...&lt;&#x2F;strong&gt; &lt;em&gt;op&lt;&#x2F;em&gt; &lt;em&gt;pack&lt;&#x2F;em&gt; &lt;strong&gt;)&lt;&#x2F;strong&gt;
&lt;strong&gt;(&lt;&#x2F;strong&gt; &lt;em&gt;pack&lt;&#x2F;em&gt; &lt;em&gt;op&lt;&#x2F;em&gt; &lt;strong&gt;...&lt;&#x2F;strong&gt; &lt;em&gt;op&lt;&#x2F;em&gt; &lt;em&gt;init&lt;&#x2F;em&gt; &lt;strong&gt;)&lt;&#x2F;strong&gt;
&lt;strong&gt;(&lt;&#x2F;strong&gt; &lt;em&gt;init&lt;&#x2F;em&gt; &lt;em&gt;op&lt;&#x2F;em&gt; &lt;strong&gt;...&lt;&#x2F;strong&gt; &lt;em&gt;op&lt;&#x2F;em&gt; &lt;em&gt;pack&lt;&#x2F;em&gt; &lt;strong&gt;)&lt;&#x2F;strong&gt;
上面四个分别对应了一元右折叠、一元左折叠、二元右折叠、二元左折叠。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;explain&quot;&gt;Explain&lt;&#x2F;h2&gt;
&lt;p&gt;上面的四种折叠，分别会被展开成：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;\text{一元右折叠:} E_1 \  \text{op}\ (\dots\ \text{op}\ (E_{N-1}\ \text{op}\ E_N))\\
\text{一元左折叠:} ((E_1\ \text{op}\ E_2)\ \text{op}\ \dots)\ \text{op}\ E_N)\\
\text{二元右折叠:} E_1 \  \text{op}\ (\dots\ \text{op}\ (E_{N-1}\ \text{op}\ (E_N\ \text{op}\ I)))\\
\text{二元左折叠:} (((I\ \text{op}\ E_1)\ \text{op}\ E_2)\ \text{op}\ \dots)\ \text{op}\ E_N)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在使用二元折叠的时候，注意两个运算符必须是一样的，并且 &lt;em&gt;init&lt;&#x2F;em&gt; 如果是一个表达式的话，优先级必须低于 &lt;em&gt;op&lt;&#x2F;em&gt;，如果一定要高于的话，可以用括号括起来。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example&quot;&gt;Example&lt;&#x2F;h2&gt;
&lt;p&gt;端序交换：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;class T, std::size_t... N&amp;gt;
constexpr T bswap_impl(T i, std::index_sequence&amp;lt;N...&amp;gt;) {
  return (((i &amp;gt;&amp;gt; N*CHAR_BIT &amp;amp; std::uint8_t(-1)) &amp;lt;&amp;lt; (sizeof(T)-1-N)*CHAR_BIT) | ...);
}
template&amp;lt;class T, class U = std::make_unsigned_t&amp;lt;T&amp;gt;&amp;gt;
constexpr U bswap(T i) {
  return bswap_impl&amp;lt;U&amp;gt;(i, std::make_index_sequence&amp;lt;sizeof(T)&amp;gt;{});
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;thinking-2&quot;&gt;Thinking&lt;&#x2F;h2&gt;
&lt;p&gt;折叠表达式是在参数包的展开上面的又一次进步和改进，弥补了原本的参数包展开不易计算的问题。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;noexcept&quot;&gt;noexcept&lt;&#x2F;h1&gt;
&lt;p&gt;noexcept 成为了类型系统的一部分，这也是C++17对以前代码的唯一影响，可能会导致以前的代码不能通过编译。
&lt;code&gt;void f();&lt;&#x2F;code&gt; 和 &lt;code&gt;void f() noexcept;&lt;&#x2F;code&gt; 不再被认为是同一个类型，所以可能要为从前的实现提供额外的模板，或者提供额外的重载，再或者可以在模板中使用C++17中的新特性指定模板类型推导（template type deduction guide）。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;template-type-deduction&quot;&gt;template type deduction&lt;&#x2F;h1&gt;
&lt;p&gt;为了实例化一个类模板，我们必须清楚的知道每个模板的类型，并且显示的写出他们，但是很多时候这是不必要的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;thinking-3&quot;&gt;Thinking&lt;&#x2F;h2&gt;
&lt;p&gt;这个新特性看起来似乎并没有那么吸引我：在类成员定义的时候，我没法使用到这个特性，可是这是我使用模板类最多的地方；在其他的很多地方，我似乎又可以使用&lt;code&gt;auto&lt;&#x2F;code&gt;来替代写出一个变量的类型来。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;References:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;if&quot;&gt;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;if&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;structured_binding&quot;&gt;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;structured_binding&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2015&#x2F;p0144r0.pdf&quot;&gt;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2015&#x2F;p0144r0.pdf&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;ADL&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;ADL: Argument-dependent lookup
&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#RVO&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;: RVO: Return Value Optimization&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
        </item>
        <item>
            <title>Const Reference of Pointer</title>
            <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/const-reference-of-pointer/</link>
            <guid>https://twistoy.com/posts/const-reference-of-pointer/</guid>
            <description>&lt;p&gt;问题起源：
在子类中实现一个模板父类的纯虚函数的时候，不能正确的通过编译。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
struct Fuck {
    virtual void shit(const T&amp;amp;) = 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;code&gt;shit&lt;&#x2F;code&gt;函数接受一个常量引用，当我们使用一个指针类型(&lt;code&gt;A*&lt;&#x2F;code&gt;)来实例化这个模板类的时候，函数&lt;code&gt;shit&lt;&#x2F;code&gt;的类型就应该是：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void shit(const T&amp;amp;) = 0; &amp;lt;value T = A*&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当我尝试用下面这样的表示来实现这个函数的时候发生了编译错误：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct FuckImpl : Fuck&amp;lt;A*&amp;gt; {
    void shit(const A*&amp;amp;) override;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里正确的写法应该是：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct FuckImpl : Fuck&amp;lt;A*&amp;gt; {
  void shit(A* const&amp;amp;) override;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个问题大概由于&lt;code&gt;const&lt;&#x2F;code&gt;修饰符的结合性的问题，在前一种写法中&lt;code&gt;const&lt;&#x2F;code&gt;并没有修饰后面的引用，而是由于结合性的原因修饰了前面的指针。所以后一种写法中，&lt;code&gt;const&lt;&#x2F;code&gt;明确的修饰了后面引用。提供了正确的类型。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;额外的吐槽：这里就要吐槽&lt;code&gt;g++&lt;&#x2F;code&gt;的报错了，我用&lt;code&gt;clang&lt;&#x2F;code&gt;编译的时候就给出了正确的表达式写法，只要抄上去就好了。2333&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>编译时期常量数组及常用操作</title>
            <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/compile-time-const-array/</link>
            <guid>https://twistoy.com/posts/compile-time-const-array/</guid>
            <description>&lt;p&gt;文中所有的代码均遵循C++11的标准并编译通过。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;const-array-de-shi-xian&quot;&gt;&lt;code&gt;const_array&lt;&#x2F;code&gt; 的实现&lt;&#x2F;h2&gt;
&lt;p&gt;在 C++11 标准中的使用&lt;code&gt;constexpr&lt;&#x2F;code&gt;修饰的函数的要求比较严格，只允许在函数体内有一个&lt;code&gt;return&lt;&#x2F;code&gt;语句。那么在这样的限制下，很多的表达式就只能使用递归来完成。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstddef&amp;gt;

template&amp;lt;typename T&amp;gt;
using Invoke = typename T::type;

template&amp;lt;size_t...&amp;gt;
struct index_sequence {
  using type = index_sequence;
};

template&amp;lt;typename S1, typename S2&amp;gt;
struct _concat_sequence;
template&amp;lt;size_t... I1, size_t... I2&amp;gt;
struct _concat_sequence&amp;lt;index_sequence&amp;lt;I1...&amp;gt;, index_sequence&amp;lt;I2...&amp;gt;&amp;gt;
    : index_sequence&amp;lt;I1..., (sizeof...(I1) + I2)...&amp;gt; {};
template&amp;lt;typename S1, typename S2&amp;gt;
using concat_sequence = Invoke&amp;lt;_concat_sequence&amp;lt;S1, S2&amp;gt;&amp;gt;;

template&amp;lt;size_t Length&amp;gt;
struct _make_index_sequence;
template&amp;lt;size_t Length&amp;gt;
using make_index_sequence = Invoke&amp;lt;_make_index_sequence&amp;lt;Length&amp;gt;&amp;gt;;
template&amp;lt;size_t Length&amp;gt;
struct _make_index_sequence
    : concat_sequence&amp;lt;make_index_sequence&amp;lt;Length&amp;#x2F;2&amp;gt;, make_index_sequence&amp;lt;Length - Length &amp;#x2F; 2&amp;gt;&amp;gt; {};
template&amp;lt;&amp;gt;
struct _make_index_sequence&amp;lt;0&amp;gt; : index_sequence&amp;lt;&amp;gt; {};
template&amp;lt;&amp;gt;
struct _make_index_sequence&amp;lt;1&amp;gt; : index_sequence&amp;lt;0&amp;gt; {};
template&amp;lt;size_t offset, typename S&amp;gt;
struct _make_offset;
template&amp;lt;size_t offset, size_t... I&amp;gt;
struct _make_offset&amp;lt;offset, index_sequence&amp;lt;I...&amp;gt;&amp;gt; : index_sequence&amp;lt;(I + offset)...&amp;gt; {};
template&amp;lt;size_t offset, typename S&amp;gt;
using make_offset = Invoke&amp;lt;_make_offset&amp;lt;offset, S&amp;gt;&amp;gt;;

template&amp;lt;typename ValueType, size_t Size&amp;gt;
class const_array {
  ValueType data_[Size];
  template&amp;lt;size_t SZ1, size_t SZ2&amp;gt;
  constexpr const_array(const_array&amp;lt;ValueType, SZ1&amp;gt; first, ValueType second, const_array&amp;lt;ValueType, SZ2&amp;gt; third)
      : const_array(first, second, third, make_index_sequence&amp;lt;SZ1&amp;gt;(), make_index_sequence&amp;lt;SZ2&amp;gt;()) {}
  template&amp;lt;size_t... I1, size_t... I2&amp;gt;
  constexpr const_array(const_array&amp;lt;ValueType, sizeof...(I1)&amp;gt; first, ValueType second, const_array&amp;lt;ValueType, sizeof...(I2)&amp;gt; third, index_sequence&amp;lt;I1...&amp;gt;, index_sequence&amp;lt;I2...&amp;gt;)
      : data_{ first[I1]..., second, third[I2]... } {}
  template&amp;lt;size_t... I&amp;gt;
  constexpr const_array(const_array&amp;lt;ValueType, Size - 1&amp;gt; arr, ValueType value, index_sequence&amp;lt;I...&amp;gt;)
      : data_{ arr[I]..., value } {}
  constexpr const_array(const_array&amp;lt;ValueType, Size - 1&amp;gt; arr, ValueType value)
      : const_array(arr, value, make_index_sequence&amp;lt;Size - 1&amp;gt;()) {}
  template&amp;lt;size_t L1, size_t L2, size_t... I1, size_t... I2&amp;gt;
  constexpr const_array(const_array&amp;lt;ValueType, L1&amp;gt; arr1,
                        const_array&amp;lt;ValueType, L2&amp;gt; arr2,
                        index_sequence&amp;lt;I1...&amp;gt;,
                        index_sequence&amp;lt;I2...&amp;gt;)
      : data_{ arr1[I1]..., arr2[I2]... } {};
  template&amp;lt;size_t... I&amp;gt;
  constexpr const_array(ValueType (&amp;amp;arr)[Size], index_sequence&amp;lt;I...&amp;gt;)
      : data_{ arr[I]... } {}

  friend class const_array&amp;lt;ValueType, Size - 1&amp;gt;;
public:
  &amp;#x2F;&amp;#x2F; construct const_array from only one element
  constexpr explicit const_array(ValueType value) : data_{ value } {}
  constexpr explicit const_array(ValueType (&amp;amp;arr)[Size])
      : const_array(arr, make_index_sequence&amp;lt;Size&amp;gt;()) {}

  template&amp;lt;size_t length, size_t... I&amp;gt;
  constexpr const_array(const_array&amp;lt;ValueType, length&amp;gt; rhs, index_sequence&amp;lt;I...&amp;gt;)
      : data_{ rhs[I]... } {}
  template&amp;lt;size_t L1, size_t L2&amp;gt;
  constexpr const_array(const_array&amp;lt;ValueType, L1&amp;gt; arr1, const_array&amp;lt;ValueType, L2&amp;gt; arr2)
      : const_array(arr1, arr2, make_index_sequence&amp;lt;L1&amp;gt;(), make_index_sequence&amp;lt;L2&amp;gt;()) {};

  template&amp;lt;size_t length, size_t st = 0&amp;gt;
  constexpr const_array&amp;lt;ValueType, length&amp;gt; sub_array() const {
    return const_array&amp;lt;ValueType, length&amp;gt;(*this, make_offset&amp;lt;st, make_index_sequence&amp;lt;length&amp;gt;&amp;gt;());
  }

  template&amp;lt;size_t i&amp;gt;
  constexpr const_array&amp;lt;ValueType, Size&amp;gt; set(ValueType value) const {
    return const_array&amp;lt;ValueType, Size&amp;gt;(
        sub_array&amp;lt;i&amp;gt;(), value, sub_array&amp;lt;Size - i - 1, i + 1&amp;gt;()
    );
  }
  template&amp;lt;size_t length&amp;gt;
  constexpr const_array&amp;lt;ValueType, Size + length&amp;gt; append(const_array&amp;lt;ValueType, length&amp;gt; rhs) const {
    return const_array&amp;lt;ValueType, Size + length&amp;gt;(*this, rhs);
  };

  constexpr const_array&amp;lt;ValueType, Size + 1&amp;gt; append(ValueType value) const {
    return const_array&amp;lt;ValueType, Size + 1&amp;gt;(*this, value);
  }
  constexpr ValueType operator[] (size_t i) const {
    return data_[i];
  }
  constexpr size_t size() const {
    return Size;
  }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在实现的过程中，借助了一个部分实现类。使用二分递归的方式实现了一个用于生成制定长度的数列的辅助类，避免了当 &lt;code&gt;N&lt;&#x2F;code&gt; 过大的时候递归过深的问题。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
using Invoke = typename T::type;

template&amp;lt;size_t...&amp;gt;
struct index_sequence {
  using type = index_sequence;
};

template&amp;lt;typename S1, typename S2&amp;gt;
struct _concat_sequence;
template&amp;lt;size_t... I1, size_t... I2&amp;gt;
struct _concat_sequence&amp;lt;index_sequence&amp;lt;I1...&amp;gt;, index_sequence&amp;lt;I2...&amp;gt;&amp;gt;
    : index_sequence&amp;lt;I1..., (sizeof...(I1) + I2)...&amp;gt; {};
template&amp;lt;typename S1, typename S2&amp;gt;
using concat_sequence = Invoke&amp;lt;_concat_sequence&amp;lt;S1, S2&amp;gt;&amp;gt;;

template&amp;lt;size_t Length&amp;gt;
struct _make_index_sequence;
template&amp;lt;size_t Length&amp;gt;
using make_index_sequence = Invoke&amp;lt;_make_index_sequence&amp;lt;Length&amp;gt;&amp;gt;;
template&amp;lt;size_t Length&amp;gt;
struct _make_index_sequence
    : concat_sequence&amp;lt;make_index_sequence&amp;lt;Length&amp;#x2F;2&amp;gt;, make_index_sequence&amp;lt;Length - Length &amp;#x2F; 2&amp;gt;&amp;gt; {};
template&amp;lt;&amp;gt;
struct _make_index_sequence&amp;lt;0&amp;gt; : index_sequence&amp;lt;&amp;gt; {};
template&amp;lt;&amp;gt;
struct _make_index_sequence&amp;lt;1&amp;gt; : index_sequence&amp;lt;0&amp;gt; {};
template&amp;lt;size_t offset, typename S&amp;gt;
struct _make_offset;
template&amp;lt;size_t offset, size_t... I&amp;gt;
struct _make_offset&amp;lt;offset, index_sequence&amp;lt;I...&amp;gt;&amp;gt; : index_sequence&amp;lt;(I + offset)...&amp;gt; {};
template&amp;lt;size_t offset, typename S&amp;gt;
using make_offset = Invoke&amp;lt;_make_offset&amp;lt;offset, S&amp;gt;&amp;gt;;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来就是借助上面的辅助类，来生成对应的数组下标帮助完成 &lt;code&gt;const_array&lt;&#x2F;code&gt; 的拷贝。我们并不能修改一个编译时期常量的类，所以这里有关于修改的操作都是通过返回一个新的对象来完成的，比如 &lt;code&gt;append&lt;&#x2F;code&gt; 和 &lt;code&gt;set&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>使用智能指针的默认行为来避免内存泄漏</title>
            <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/leak-freedom-in-cpp-by-default/</link>
            <guid>https://twistoy.com/posts/leak-freedom-in-cpp-by-default/</guid>
            <description>&lt;p&gt;2016年的 cppcon 上，Herb Sutter 的演讲中提出了一些关于常用的数据结构如何使用智能指针自动的构造和析构来避免内存泄漏的情况发生。
可以在这里找到这个演讲的链接：&lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;JfmTagWcqoE&quot;&gt;https:&#x2F;&#x2F;youtu.be&#x2F;JfmTagWcqoE&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;zhi-neng-zhi-zhen&quot;&gt;智能指针&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;unique-ptr&quot;&gt;&lt;code&gt;unique_ptr&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;唯一所有权&lt;&#x2F;li&gt;
&lt;li&gt;离开作用域时，会同时析构指向的对象&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;shared-ptr&quot;&gt;&lt;code&gt;shared_ptr&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;共享所有权&lt;&#x2F;li&gt;
&lt;li&gt;最后一个指向对象的 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 被销毁时，析构指向的对象&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;weak-ptr&quot;&gt;&lt;code&gt;weak_ptr&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;不表示所有权&lt;&#x2F;li&gt;
&lt;li&gt;使用之前需要先创建一个 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt;（通过 &lt;code&gt;wp.lock()&lt;&#x2F;code&gt;，这个操作会延长指向对象的生命周期到这个临时的 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 被销毁时）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;suo-you-quan-ownership&quot;&gt;所有权（Ownership）&lt;&#x2F;h2&gt;
&lt;p&gt;在这里我借用了 &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;en-US&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt; 中的一个概念：所有权（Ownership），也就是表示一个对象持有（HAS-A）另一个对象，被持有的对象的生命周期应该和其父对象的生命周期相同。通常，在 C++ 中，我们都会使用数据成员（data member）的方式去表示这样的关系。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class MyClass {
  Data data;
  &amp;#x2F;*...*&amp;#x2F;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这用的使用情况下，如果我们需要一个更灵活一些的方案，可是同时也要具有这种持有的关系，这时候可以选择 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt;，即有了如下方案：（这种方案也可以被称作 &lt;em&gt;Decoupled HAS-A&lt;&#x2F;em&gt; ）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class MyClass {
  unique_ptr&amp;lt;Data&amp;gt; pdata;
  &amp;#x2F;*...*&amp;#x2F;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;chang-jian-shi-yong-chang-jing&quot;&gt;常见使用场景&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;zhi-xiang-shi-xian-de-zhi-zhen-pimpl-idiom&quot;&gt;指向实现的指针（Pimpl Idiom）&lt;&#x2F;h3&gt;
&lt;p&gt;很多时候我们会有需要将一些实现抽象出来到一个单独的类中，来实现接口和实现分离。在这样的场景下，我们对 &lt;code&gt;pImpl&lt;&#x2F;code&gt; 是不会有改变的，在这样的情况下，使用 &lt;code&gt;const unique_ptr&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;class T&amp;gt;
using PImpl = const unique_ptr&amp;lt;T&amp;gt;;

class MyClass {
  class Impl;
  PImpl&amp;lt;Impl&amp;gt; pImpl;
  &amp;#x2F;*...*&amp;#x2F;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;dong-tai-shu-zu-cheng-yuan-dynamic-array-member&quot;&gt;动态数组成员（Dynamic Array Member）&lt;&#x2F;h3&gt;
&lt;p&gt;这里有两种方案，一种是使用 STL 里的 &lt;code&gt;vector&lt;&#x2F;code&gt;，另一种就是使用 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt;。对于那些长度可能会变化的需求，我倾向于 &lt;code&gt;unique_ptr&amp;lt;vector&amp;gt;&lt;&#x2F;code&gt;；而对于长度偏固定的场景下，直接使用数组的指针我觉得会是一个较好的选择：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class MyClss {
  const unique_ptr&amp;lt;Data[]&amp;gt; array;
  int array_size;
  &amp;#x2F;*...*&amp;#x2F;
  MyClass (size_t num_data) :
    array(make_unique&amp;lt;Data[]&amp;gt;(num_data)) {}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shu-tree&quot;&gt;树（Tree）&lt;&#x2F;h3&gt;
&lt;p&gt;一个我们想象中常见的二叉树，在每个节点上保存了其子节点和要保存的数据。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;image&#x2F;autoupload&#x2F;blog-tree-1.jpg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在这样的结构里，我们可以发现父节点持有着它的两个子节点，而且每个子节点仅被其父节点持有，在这样的情况下，显然应该使用 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class Tree {
  struct Node {
    vector&amp;lt;unique_ptr&amp;lt;Node&amp;gt;&amp;gt; children;
    &amp;#x2F;*...*&amp;#x2F;
  };
  unique_ptr&amp;lt;Node&amp;gt; root;
  &amp;#x2F;*...*&amp;#x2F;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;那如果每个节点上还保存了其父节点的信息呢，显然我们不能再使用一个 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt; 来保存父节点的指针，因为这样就和 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt; 的意义冲突了，并且会导致内存泄漏的情况。所以这里，就直接使用 raw pointer 去表示一个节点的父节点就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;如果我们在程序的其他地方，需要一些额外的指针来指向树中节点所保存的信息，看起来和下图差不多：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;image&#x2F;autoupload&#x2F;blog-tree-2.jpg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在这种情况下，每个节点的所有权就不是唯一的，不再是它的父节点，可能是外部可能的任何一个对象，在这种情况下，就需要把使用的 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt; 变成 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt;。在这个基础上，我们可以方便的对外提供任意节点保存信息的指针（也是一个 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class Tree {
  struct Node {
    vector&amp;lt;shared_ptr&amp;lt;Node&amp;gt;&amp;gt; children;
    Data data;
  };
  shared_ptr&amp;lt;Node&amp;gt; root;
  shared_ptr&amp;lt;Data&amp;gt; find(&amp;#x2F;*...*&amp;#x2F;) {
    &amp;#x2F;*...*&amp;#x2F;
    return {spn, &amp;amp;(spn-&amp;gt;data)};
  }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;代码的倒数第三行中使用了 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 的 &lt;code&gt;aliasing constructor&lt;&#x2F;code&gt;，提供了指向的内容的指针和用于管理这个指针的另一个 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 对象。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shuang-xiang-lian-biao-doubly-linked-list&quot;&gt;双向链表（Doubly Linked List）&lt;&#x2F;h3&gt;
&lt;p&gt;在一个双向链表中，我们用两个指针去表示前节点和后节点，在这样的情况下，我们会出现和上面树中相似的问题，在这种情况下，我们依旧可以使用 &lt;code&gt;unique_ptr + raw pointer&lt;&#x2F;code&gt; 的解决方案。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class LinkedList {
  struct Node {
    unique_ptr&amp;lt;Node&amp;gt; next;
    Node* prev;
    &amp;#x2F;*... data ...*&amp;#x2F;
  };
  unique_ptr&amp;lt;Node&amp;gt; root;
  &amp;#x2F;*...*&amp;#x2F;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;you-xiang-wu-huan-tu-dag&quot;&gt;有向无环图（DAG）&lt;&#x2F;h3&gt;
&lt;p&gt;一个 DAG 和一棵树的区别是：在树中一个节点只能是另一个节点的子节点；而在 DAG 中，一个节点可以是多个节点的后继节点。在这样的基础下，我们把每个节点的 &lt;code&gt;unique_ptr&lt;&#x2F;code&gt; 改成 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 就可以工作了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class DAG {
  struct Node {
    vector&amp;lt;shared_ptr&amp;lt;Node&amp;gt;&amp;gt; children;
    vector&amp;lt;Node*&amp;gt; parents;
  &amp;#x2F;*… data …*&amp;#x2F;
  };
  vector&amp;lt;shared_ptr&amp;lt;Node&amp;gt;&amp;gt; roots;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;huan-xing-lian-biao-circular-list&quot;&gt;环形链表（Circular List）&lt;&#x2F;h3&gt;
&lt;p&gt;在环形链表中，我们不可避免的要处理一个节点被多个对象拥有的情况。但是，仔细考虑一下，这样的冲突只会发生在链表的头部，因为它会同时被最后一个节点和表示链表的头指针持有，那在这种情况下，我们可以选择断开最后一个节点和头节点的关系，即按照一个非环的单项链表存储，然后在最后一个节点的部分对其做特殊处理。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;class CircularList {
  class Node {
    unique_ptr&amp;lt;Node&amp;gt; next;
    unique_ptr&amp;lt;Node&amp;gt;&amp;amp; head;
  public:
    auto get_next() { return next ? next.get(): head.get(); }
  };
  unique_ptr&amp;lt;Node&amp;gt; head;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;unique_ptr&lt;&#x2F;li&gt;
&lt;li&gt;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;shared_ptr&lt;&#x2F;li&gt;
&lt;li&gt;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;weak_ptr&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>Python元编程 - 在Python中实现重载</title>
            <pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/python-meta-programming-1/</link>
            <guid>https://twistoy.com/posts/python-meta-programming-1/</guid>
            <description>&lt;p&gt;避免重复的代码，避免复制粘贴一些逻辑的时候，我们使用了函数。那么避免复制粘贴定义一些类似的，或者较为相像的类的时候，我们就需要一个生成类的方法，在Python中，我们使用的方法就是元类（MetaClass）。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;yuan-bian-cheng-de-ying-yong-1-han-shu-zhong-zai&quot;&gt;元编程的应用（1）函数重载&lt;&#x2F;h2&gt;
&lt;p&gt;在 Python 中，如果我们想要实现一个可以接受多种参数的函数，我们通常的方法都是在函数体里判断参数的个数，和各个的类型。这个办法很麻烦，并且也不容易维护，我也很希望可以像 C++ 一样可以简单的使用同样的名字去重载函数。利用元编程就可以做到。&lt;&#x2F;p&gt;
&lt;p&gt;我想做到像下面这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class Fuck:
	def shit(self, x: int, y: int):
    	pass
    def shit(self, p: str):
    	pass

fuck = Fuck()
fuck.shit(1, 2)
fuck.shit(&amp;quot;f&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;首先是一个用来存重复函数的类，负责把一个函数的签名提取出来，存到一个 &lt;code&gt;dict&lt;&#x2F;code&gt; 里，在被运行的时候，按照参数类型找到存好的重载。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import inspect, types
class MultiMethod:
   def __init__(self, name):
       self._methods = {}
       self.__name__ = name

   def insert_method(self, key, method):
       if key in self._methods:
           raise TypeError(
               &amp;quot;Can&amp;#x27;t insert arguments {}, already exists.&amp;quot;.format(&amp;quot;,&amp;quot;.join([str(x) for x in key]))
           )
       self._methods[key] = method

   def register(self, method):
       sig = inspect.signature(method)

       arguments = []
       for name, parm in sig.parameters.items():
           if name == &amp;quot;self&amp;quot;:
               continue
           if parm.annotation is inspect.Parameter.empty:
               raise TypeError(
                   &amp;quot;Argument {} must be annotated with a type.&amp;quot;.format(name)
               )
           if not isinstance(parm.annotation, type):
               raise TypeError(
                   &amp;quot;Argument {} annotation must be a type.&amp;quot;.format(name)
               )
           if parm.default is not inspect.Parameter.empty:
               self.insert_method(tuple(arguments), method)
           arguments.append(parm.annotation)
       self.insert_method(tuple(arguments), method)

   def __call__(self, *args):
       arguments = tuple(type(arg) for arg in args[1:])
       method = self._methods.get(arguments, None)
       if method:
           return method(*args)
       else:
           raise TypeError(&amp;quot;No matching method for types {}&amp;quot;.format(arguments))

   def __get__(self, instance, cls):
       if instance is not None:
           return types.MethodType(self, instance)
       else:
           return self
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;dict&lt;&#x2F;code&gt; 类的子类，用于 &lt;code&gt;__prepare__&lt;&#x2F;code&gt; 函数的返回值，在 &lt;code&gt;__setitem__&lt;&#x2F;code&gt; 方法中进行实际的注册工作。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class MultiDict(dict):
    def __setitem__(self, key, value):
        if key in self:
            current_value = self[key]
            if isinstance(current_value, MultiMethod):
                current_value.register(value)
            else:
                mvalue = MultiMethod(key)
                mvalue.register(current_value)
                mvalue.register(value)
                super().__setitem__(key, mvalue)
        else:
            super().__setitem__(key, value)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最后是支持函数重载的元类。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class MultipleMeta(type):
    def __new__(cls, name, bases, clsdict):
        return type.__new__(cls, name, bases, clsdict)

    @classmethod
    def __prepare__(cls, name, bases):
        return MultiDict()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>C++ 中的类型推导</title>
            <pubDate>Thu, 09 Feb 2017 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/cpp11-type-derivation/</link>
            <guid>https://twistoy.com/posts/cpp11-type-derivation/</guid>
            <description>&lt;h1 id=&quot;auto-de-ji-ben-shi-yong&quot;&gt;auto 的基本使用&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;auto&lt;&#x2F;code&gt; 关键字被在变量声明或者作为函数返回值的占位符，在这两个位置的使用是可以通过单个等号右边，或者函数调用来确定 &lt;code&gt;auto&lt;&#x2F;code&gt; 具体应该成为什么类型的，比如像下面这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;auto iter = map.begin();
template&amp;lt;typename T, typename U&amp;gt;
auto func(T a, U b) -&amp;gt; decltype(a + b);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;在 C++14 中，后面的 &lt;code&gt;decltype&lt;&#x2F;code&gt; 部分也可以被省略，可以通过返回的表达式来直接推导，比如这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T, typename U&amp;gt;
auto func(T a, U b) {
  return a + b;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;for-range-loop&quot;&gt;for-range loop&lt;&#x2F;h2&gt;
&lt;p&gt;还可以被用于在 for-range loop 中使用，作为循环变量类型的占位。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;for-range-loop-de-zhan-kai&quot;&gt;for-range loop 的展开&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;{
  auto&amp;amp;&amp;amp; __range = range_expression;
  for (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement;
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;展开中的 &lt;code&gt;begin_expr&lt;&#x2F;code&gt; 和 &lt;code&gt;end_expr&lt;&#x2F;code&gt; 都分别用 &lt;code&gt;std::begin(you_container)&lt;&#x2F;code&gt; 和 &lt;code&gt;std::end(you_container)&lt;&#x2F;code&gt; 来得到其实和终止的迭代器。
在这两个函数的内部会分别调用 &lt;code&gt;begin()&lt;&#x2F;code&gt; 和 &lt;code&gt;end()&lt;&#x2F;code&gt; 的成员函数来确定边界，边界应该是左闭右开的。&lt;&#x2F;p&gt;
&lt;p&gt;所以如果想要通过 for-range loop 来遍历自定义的数据结构的话，需要为这个数据结构提供 &lt;code&gt;begin()&lt;&#x2F;code&gt; 和 &lt;code&gt;end()&lt;&#x2F;code&gt; 两个成员函数，并且提供一个迭代器类型，
迭代器类型需要可以拷贝，并且重载了 &lt;code&gt;!=&lt;&#x2F;code&gt; 、前置 &lt;code&gt;++&lt;&#x2F;code&gt; 运算符和解引用（&lt;code&gt;*&lt;&#x2F;code&gt;）运算符。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;auto-zhan-wei-fu-de-shi-yong&quot;&gt;auto 占位符的使用&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;for (auto x: m) {
  ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个占位符有四种写法：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;for (auto x: m);
for (auto&amp;amp; x: m);
for (const auto&amp;amp; x: m);
for (auto&amp;amp;&amp;amp; x: m);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;for-auto-x-m&quot;&gt;&lt;code&gt;for (auto x: m)&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;这种写法情况，被遍历的每一个元素都会被拷贝一次，也就是说在 &lt;code&gt;for&lt;&#x2F;code&gt; 的代码块中使用的是被遍历元素的一个拷贝。
所以这里就有一个情况是不能使用的，就是如果被遍历元素的类型不能拷贝，那么就不能用，比如 &lt;code&gt;std::unique_ptr&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;for-auto-x-m-1&quot;&gt;&lt;code&gt;for (auto&amp;amp; x: m)&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;这样的写法大部分情况是没有问题的，元素不会被拷贝，而且可以在遍历的时候被修改。那么唯一会出问题的情况就是被遍历的对象是 &lt;code&gt;vector&amp;lt;bool&amp;gt;&lt;&#x2F;code&gt; 的时候。
&lt;code&gt;vector&amp;lt;bool&amp;gt;&lt;&#x2F;code&gt; 是 &lt;code&gt;vector&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; 的一个特化，使用了位去存储元素，所以在遍历的时候返回的是一个 bit reference 对象，这个对象是不能被非 const 的
左值引用中。所以在这种情况下，是不能用这种遍历方法的。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;for-const-auto-x-m&quot;&gt;&lt;code&gt;for (const auto&amp;amp; x: m)&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;const 的左值引用作为在 C++ 中的万能类型，可以接受这个类型的任何对象，除了元素不能修改之外，可以在大部分情况中使用。作为引用，也不会引起额外的拷贝开销。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;for-auto-x-m-2&quot;&gt;&lt;code&gt;for (auto&amp;amp;&amp;amp; x: m)&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;auto&amp;amp;&amp;amp;&lt;&#x2F;code&gt; 可以被称为 Universal References，这里不是指它能兼容所有的引用类型，而是会因为引用折叠的原因可以根据 &lt;code&gt;auto&lt;&#x2F;code&gt; 推导出来的类型对实际类型做出改变。
所以如果在这里使用这种写法的话，就可以接受任意类型，并且可以修改其中的元素。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;auto-he-decltype-de-tui-dao&quot;&gt;&lt;code&gt;auto&lt;&#x2F;code&gt; 和 &lt;code&gt;decltype&lt;&#x2F;code&gt; 的推导&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;auto-de-tui-dao&quot;&gt;&lt;code&gt;auto&lt;&#x2F;code&gt; 的推导&lt;&#x2F;h2&gt;
&lt;p&gt;不包含引用的推导：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;auto a = 1; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, a -&amp;gt; int
auto b = new auto(2); &amp;#x2F;&amp;#x2F; auto int*, a -&amp;gt; int*
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;包含指针的推导：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a = 1;
auto *b = &amp;amp;a; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, b -&amp;gt; int*
auto c = &amp;amp;a; &amp;#x2F;&amp;#x2F; auto - int*, c -&amp;gt; int*
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;包含引用的推导：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int a = 1;
auto&amp;amp; d = a; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, d -&amp;gt; int&amp;amp;
auto e = a; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, e -&amp;gt; int

&amp;#x2F;&amp;#x2F; CV 限定会在 auto 的推导中被丢弃
const auto f = a; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, f -&amp;gt; const int
auto g = f; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, g -&amp;gt; int

&amp;#x2F;&amp;#x2F; 如果 auto 被引用修饰，那么表达式的 CV 限定将会被保留
auto const &amp;amp;h = a; &amp;#x2F;&amp;#x2F; auto -&amp;gt; int, h -&amp;gt; int const&amp;amp;
auto &amp;amp;i = h; &amp;#x2F;&amp;#x2F; auto -&amp;gt; const int, i -&amp;gt; cosnt int&amp;amp;
auto *j = &amp;amp;h; &amp;#x2F;&amp;#x2F; auto -&amp;gt; const int, j -&amp;gt; const int*
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;decltype-de-tui-dao&quot;&gt;&lt;code&gt;decltype&lt;&#x2F;code&gt; 的推导&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;const std::vector&amp;lt;int&amp;gt; v;
auto a = v[0]；&amp;#x2F;&amp;#x2F; a -&amp;gt; int
decltype（v[0]) b = 0; &amp;#x2F;&amp;#x2F; b -&amp;gt; const int&amp;amp;

int c = 0;
decltype(c) d; &amp;#x2F;&amp;#x2F; d -&amp;gt; int
decltype((c)) e; &amp;#x2F;&amp;#x2F; e -&amp;gt; int&amp;amp;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大概就是 decltype 会反映里面表达式的类型，不会去掉对应的CV限定符。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;C%2B%2B11#.E5.9E.8B.E5.88.A5.E6.8E.A8.E5.B0.8E&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;isocpp.org&#x2F;blog&#x2F;2012&#x2F;11&#x2F;universal-references-in-c11-scott-meyers&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        <item>
            <title>在 CLion 中配置 gtest</title>
            <pubDate>Sun, 13 Nov 2016 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/gtest-in-clion/</link>
            <guid>https://twistoy.com/posts/gtest-in-clion/</guid>
            <description>&lt;p&gt;最近在学习 googletest 这个用于 C++ 的单元测试框架的时候，遇到了一个问题。就是希望可以在 CLion 中配置好一个制定项目的测试，然后由 CLion 运行并且给出一个结果。
结果当然是成功了的，这篇文章主要就记录一下整个配置的过程，配置过程整体很简单，主要就是写 CMakeLists.txt 的过程（因为 CLion 使用 CMakeLists 管理整个 C++ 的项目）。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;xiang-mu-mu-lu-jie-gou&quot;&gt;项目目录结构&lt;&#x2F;h1&gt;
&lt;pre&gt;&lt;code&gt;+ project_home
  + ext &amp;#x2F;&amp;#x2F; external library
    + gtest &amp;#x2F;&amp;#x2F; google test framework
	  - CMakeLists.txt
  + include &amp;#x2F;&amp;#x2F; project headers
  + src &amp;#x2F;&amp;#x2F; project source files
  + test &amp;#x2F;&amp;#x2F; test files
  - CMakeLists.txt
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;这里假定我们把 gtest 放在 &lt;code&gt;ext&lt;&#x2F;code&gt; 这个目录下。我们不需要手动的从 github 上下载 gtest，CMake 可以替我们做到这个部分。具体的命令在后面会写到。
test 目录就是用于存放单元测试文件的地方，这部分的 cpp 文件是不需要写 main 的，在链接的时候，会把 main 函数链接上去。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ext-gtest-cmakelists-txt&quot;&gt;ext&#x2F;gtest&#x2F;CMakeLists.txt&lt;&#x2F;h1&gt;
&lt;p&gt;这部分的 CMakeLists.txt 会作为一个子文件夹在整个项目的 CMakeLists.txt 被使用。所以，这里是一个单独的 project。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.6)
project(gtest_builder)
include(ExternalProject)

set(GTEST_FORCE_SHARED_CRT ON)
set(GTEST_DISABLE_PTHREADS OFF)

ExternalProject_Add(googletest
    GIT_REPOSITORY https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;google&amp;#x2F;googletest.git
    CMAKE_ARGS -DCMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG:PATH=DebugLibs
    -DCMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE:PATH=ReleaseLibs
    -DCMAKE_CXX_FLAGS=${MSVC_COMPILER_DEFS}
    -Dgtest_force_shared_crt=${GTEST_FORCE_SHARED_CRT}
    -Dgtest_disable_pthreads=${GTEST_DISABLE_PTHREADS}
    -DBUILD_GTEST=ON
    PREFIX &amp;quot;${CMAKE_CURRENT_BINARY_DIR}&amp;quot;
    # Disable install step
    INSTALL_COMMAND &amp;quot;&amp;quot;
    )

# Specify include dir
ExternalProject_Get_Property(googletest source_dir)
set(GTEST_INCLUDE_DIRS ${source_dir}&amp;#x2F;googletest&amp;#x2F;include PARENT_SCOPE)

# Specify MainTest&amp;#x27;s link libraries
ExternalProject_Get_Property(googletest binary_dir)
set(GTEST_LIBS_DIR ${binary_dir}&amp;#x2F;googlemock&amp;#x2F;gtest PARENT_SCOPE)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里用到了 CMake 的一个模块 &lt;code&gt;ExternalProject&lt;&#x2F;code&gt;，文档在这里：&lt;a href=&quot;https:&#x2F;&#x2F;cmake.org&#x2F;cmake&#x2F;help&#x2F;v3.7&#x2F;module&#x2F;ExternalProject.html&quot;&gt;传送门&lt;&#x2F;a&gt;。
最后把下载好的 googletest 的头文件目录和编译好的链接库的目录返回给项目的 CMakeLists.txt。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;cmakelists-txt&quot;&gt;CMakeLists.txt&lt;&#x2F;h1&gt;
&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.6)
set(PROJECT_NAME_STR gtest_usage)
project(${PROJECT_NAME_STR})

find_package(Threads REQUIRED)

add_definitions(-Wall -std=c++11 -Wno-deprecated -pthread)

set(COMMON_INCLUDES  ${PROJECT_SOURCE_DIR}&amp;#x2F;include)
set(EXT_PROJECTS_DIR ${PROJECT_SOURCE_DIR}&amp;#x2F;ext)

add_subdirectory(${EXT_PROJECTS_DIR}&amp;#x2F;gtest)

enable_testing()

set(PROJECT_TEST_NAME ${PROJECT_NAME_STR}_test)
include_directories(${GTEST_INCLUDE_DIRS} ${COMMON_INCLUDES})

file(GLOB TEST_SRC_FILES ${PROJECT_SOURCE_DIR}&amp;#x2F;test&amp;#x2F;*.cpp)
add_executable(${PROJECT_TEST_NAME} ${TEST_SRC_FILES})
add_dependencies(${PROJECT_TEST_NAME} googletest)

if(NOT WIN32 OR MINGW)
  target_link_libraries(${PROJECT_TEST_NAME}
      ${GTEST_LIBS_DIR}&amp;#x2F;libgtest.a
      ${GTEST_LIBS_DIR}&amp;#x2F;libgtest_main.a
      )
else()
  target_link_libraries(${PROJECT_TEST_NAME}
      debug ${GTEST_LIBS_DIR}&amp;#x2F;DebugLibs&amp;#x2F;${CMAKE_FIND_LIBRARY_PREFIXES}gtest${CMAKE_FIND_LIBRARY_SUFFIXES}
      optimized ${GTEST_LIBS_DIR}&amp;#x2F;ReleaseLibs&amp;#x2F;${CMAKE_FIND_LIBRARY_PREFIXES}gtest${CMAKE_FIND_LIBRARY_SUFFIXES}
      )
  target_link_libraries(${PROJECT_TEST_NAME}
      debug ${GTEST_LIBS_DIR}&amp;#x2F;DebugLibs&amp;#x2F;${CMAKE_FIND_LIBRARY_PREFIXES}gtest_main${CMAKE_FIND_LIBRARY_SUFFIXES}
      optimized ${GTEST_LIBS_DIR}&amp;#x2F;ReleaseLibs&amp;#x2F;${CMAKE_FIND_LIBRARY_PREFIXES}gtest_main${CMAKE_FIND_LIBRARY_SUFFIXES}
      )
endif()

target_link_libraries(${PROJECT_TEST_NAME} ${CMAKE_THREAD_LIBS_INIT})
add_test(test1 ${PROJECT_TEST_NAME})
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的前面和配置一个正常的项目没什么不同的，都是配置头文件位置，配置链接库位置。唯一的区别是最后不是 &lt;code&gt;add_executable&lt;&#x2F;code&gt; 而是 &lt;code&gt;add_test&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;到这里应给整个项目都配置好了，然后就可以在 CLion 的右上角找到。这样的部分：&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;image&#x2F;autoupload&#x2F;gtest-in-clion-1.jpg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;CLion 可以识别出来这个是使用的 gtest 框架。然后就可以成功的运行啦！CLion 会在下面给出单元测试的报告，包括了每个 test case 的运行时间和结果。&lt;&#x2F;p&gt;
&lt;p&gt;快去试一试吧~&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;参考链接：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;snikulov&#x2F;google-test-examples&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;googletest&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        <item>
            <title>Two Ways Algorithm</title>
            <pubDate>Fri, 16 Sep 2016 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/two-ways-algorithm/</link>
            <guid>https://twistoy.com/posts/two-ways-algorithm/</guid>
            <description>&lt;p&gt;Two Ways Algorithm 是一个用于字符串匹配的算法，算法类似 KMP 会返回所有 pattern 出现在 text 里的位置。但是和 KMP 不同的是 two ways algorithm 只使用常数大小的额外空间。&lt;&#x2F;p&gt;
&lt;p&gt;算法使用 \(O(m)\) 的时间预处理，并且可以在 \(O(n)\) 时间完成匹配，在最差的情况下会遍历 text 串两次。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;suan-fa-xi-jie&quot;&gt;算法细节&lt;&#x2F;h2&gt;
&lt;p&gt;模式串 \(x\) 被分成两个部分，\(x_l\) 和 \(x_r\)。在匹配的过程中先从左向右匹配 \(x_r\)，如果没有失配再从右向左匹配 \(x_l\)。&lt;&#x2F;p&gt;
&lt;p&gt;所以算法的关键就在于怎么找到一个合理的划分，把模式串划分成两个不相交的子串。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yu-chu-li-bu-fen&quot;&gt;预处理部分&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;&#x2F;strong&gt;：&lt;em&gt;period of pattern \(x\)&lt;&#x2F;em&gt;，有整数 \(p\) 满足：\[x[i]=x[i+p]\]
换句话说，就是在模式串中任意两个相距为 &lt;em&gt;period&lt;&#x2F;em&gt; 的字符都相同。&lt;&#x2F;p&gt;
&lt;p&gt;所有满足上面条件的 \(p\) 中最小的一个，叫做这个串的 &lt;em&gt;period&lt;&#x2F;em&gt;，记做 \(p(x)\)。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;&#x2F;strong&gt;：对于任意一个位置 \(l\)（这里指的是字母之间的位置，包括最开始和最后，所以一共有 \(m+1\) 个。）有整数 \(r\) 满足 \[x[i]=x[i+r],l-r+1\le i \le l\]
所有满足上面条件的 \(r\) 中最小的一个，叫做在位置 \(l\) 上的 &lt;em&gt;local period&lt;&#x2F;em&gt;，记做 \(r(x,l)\)。&lt;&#x2F;p&gt;
&lt;p&gt;这里显然可以知道的是，对于在所有位置上的 &lt;em&gt;local period&lt;&#x2F;em&gt; 都应该有：\(1 \le r(x,l) \le |x|\)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;image&#x2F;blog&#x2F;two-ways-algorithm&#x2F;fig1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一个位置叫做 &lt;em&gt;critical position&lt;&#x2F;em&gt; 当且仅当 \[r(x,l)=p(x)\]&lt;&#x2F;p&gt;
&lt;p&gt;把这个串以这些 &lt;em&gt;critical position&lt;&#x2F;em&gt; 分开都是可以的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pi-pei-bu-fen&quot;&gt;匹配部分&lt;&#x2F;h3&gt;
&lt;p&gt;。。。TODO。。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust Ownership System</title>
            <pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/rust-ownership-system/</link>
            <guid>https://twistoy.com/posts/rust-ownership-system/</guid>
            <description>&lt;h1 id=&quot;rust-ownership-system&quot;&gt;Rust Ownership System&lt;&#x2F;h1&gt;
&lt;p&gt;基于作用域和栈的内存管理是很符合直觉的，就像下面这样。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
	let i = 5;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;这里的变量 &lt;code&gt;i&lt;&#x2F;code&gt; 最后离开了作用域，然后内存被回收。&lt;&#x2F;p&gt;
&lt;p&gt;而在下面这个例子里，变量被析构了两次。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
	let i = 5;
    foo(i);
}
fn foo(i: i64) {
	&amp;#x2F;&amp;#x2F; do something...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一次析构发生在 &lt;code&gt;foo&lt;&#x2F;code&gt; 结束的时候，第二次发生在 &lt;code&gt;main&lt;&#x2F;code&gt; 函数结束的时候。如果在 &lt;code&gt;foo&lt;&#x2F;code&gt; 中修改了这个变量的话，并不会影响到在 &lt;code&gt;main&lt;&#x2F;code&gt; 中的值。因为这里是的变量是被 &lt;strong&gt;拷贝&lt;&#x2F;strong&gt; 了一份，用于 &lt;code&gt;foo&lt;&#x2F;code&gt; 的。&lt;&#x2F;p&gt;
&lt;p&gt;在 Rust 中，使用了一套特别的基于 &lt;strong&gt;Ownership&lt;&#x2F;strong&gt; 的条件，除非一个类型被声明了具有&lt;code&gt;Copy&lt;&#x2F;code&gt;的特性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;copy-trait&quot;&gt;Copy Trait&lt;&#x2F;h2&gt;
&lt;p&gt;声明一个类型具有 &lt;code&gt;Copy&lt;&#x2F;code&gt; 标记，会在赋值或者作为函数调用参数的时候，使用 &lt;strong&gt;Copy&lt;&#x2F;strong&gt; ，而非 &lt;strong&gt;Move&lt;&#x2F;strong&gt; 的方式。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Copy, Clone)]
struct Info {
	value: i64,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ownership&quot;&gt;Ownership&lt;&#x2F;h2&gt;
&lt;p&gt;Ownership rules 保证在任何的时间，对于一个非拷贝标记的对象，有且只有一个 &lt;code&gt;owner&lt;&#x2F;code&gt; 可以修改。&lt;&#x2F;p&gt;
&lt;p&gt;因此，当一个函数退出要清理变量的时候，可以保证在今后不会被访问，修改或者删除。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::io;
use std::fmt;

struct Fuck {
    shit: String,
}

impl Fuck {
    fn new (shit: &amp;amp;str) -&amp;gt; Fuck {
        println!(&amp;quot;New... {}&amp;quot;, shit);
        Fuck { shit: shit.to_string() }
    }
}

impl Drop for Fuck {
    fn drop(&amp;amp;mut self) {
        println!(&amp;quot;Drop... {}&amp;quot;, self.shit);
    }
}

impl fmt::Debug for Fuck {
    fn fmt(&amp;amp;self, f: &amp;amp;mut fmt::Formatter) -&amp;gt; fmt::Result {
        write!(f, &amp;quot;fuck shit:{:?}&amp;quot;, self.shit)
    }
}

fn foo(fuck: Fuck) {
    println!(&amp;quot;Call foo... {:?}&amp;quot;, fuck);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于一个简单的 &lt;code&gt;main&lt;&#x2F;code&gt; 函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
	let mut a = Fuck::new(&amp;quot;A&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;结果是：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;New... A
End Main...
Drop... A
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于这个复杂一点的版本：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut a = Fuck::new(&amp;quot;A&amp;quot;);
    foo(a);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;结果是：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;New... A
Call foo... fuck shit:&amp;quot;A&amp;quot;
Drop... A
End Main...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;会发现在函数 &lt;code&gt;foo&lt;&#x2F;code&gt; 结束的时候，对象就被回收了。这是因为这个对象的 &lt;code&gt;owner&lt;&#x2F;code&gt; 在函数调用这个过程中从 &lt;code&gt;main&lt;&#x2F;code&gt; 函数里的 &lt;code&gt;a&lt;&#x2F;code&gt; 变成了 &lt;code&gt;foo&lt;&#x2F;code&gt; 函数里的 &lt;code&gt;fuck&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;当尝试在调用一次 &lt;code&gt;foo&lt;&#x2F;code&gt; 之后再调用一次 &lt;code&gt;foo&lt;&#x2F;code&gt; 的话，就会报错。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut a = Fuck::new(&amp;quot;A&amp;quot;);
    foo(a);
    foo(a);
    println!(&amp;quot;End Main...&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;src&amp;#x2F;main.rs:34:9: 34:10 error: use of moved value: `a` [E0382]
src&amp;#x2F;main.rs:34     foo(a);
                       ^
src&amp;#x2F;main.rs:33:9: 33:10 note: value moved here
src&amp;#x2F;main.rs:33     foo(a);
                       ^
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过这样的编译时期的检查，保证了同一时间只有一个变量拥有这个对象。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;simple-rules&quot;&gt;Simple Rules&lt;&#x2F;h2&gt;
&lt;p&gt;为了实现 &lt;em&gt;没有垃圾回收机制的内存安全&lt;&#x2F;em&gt;， 编译器不用去追踪每一个变量在代码中的使用，而是只要很简单的关注一个 &lt;strong&gt;作用域&lt;&#x2F;strong&gt; 就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;其实可以总结成一个简单的规则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;不被使用的返回值会被销毁。&lt;&#x2F;li&gt;
&lt;li&gt;所有和变量绑定的对象在离开作用域的时候会被销毁，除非这个变量不再持有这个对象。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;reference-and-borrowing&quot;&gt;Reference and Borrowing&lt;&#x2F;h2&gt;
&lt;p&gt;上面说了，当一个变量作为函数调用的参数或者赋值操作的右值的时候，这个变量会失去这个对象的所有权。就像这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut a = Fuck::new(&amp;quot;A&amp;quot;);
    foo(a);
    println!(&amp;quot;HAHA... {}&amp;quot;, a.shit);
    println!(&amp;quot;End Main...&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;src&amp;#x2F;main.rs:34:28: 34:34 error: use of moved value: `a.shit` [E0382]
src&amp;#x2F;main.rs:34     println!(&amp;quot;HAHA... {}&amp;quot;, a.shit);
                                          ^~~~~~
src&amp;#x2F;main.rs:33:9: 33:10 note: value moved here
src&amp;#x2F;main.rs:33     foo(a);
                       ^
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果希望拿回变量的所有权，我们可以把对象作为返回值传回来。就像这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn foo(fuck: Fuck) -&amp;gt; Fuck {
    println!(&amp;quot;Call foo... {:?}&amp;quot;, fuck);
    fuck
}

fn main() {
    let mut a = Fuck::new(&amp;quot;A&amp;quot;);
    a = foo(a);
    println!(&amp;quot;HAHA... {}&amp;quot;, a.shit);
    println!(&amp;quot;End Main...&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是不能每次都这么做啊，所以就有了 &lt;code&gt;borrow&lt;&#x2F;code&gt; 和 &lt;code&gt;reference&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;一个&lt;code&gt;borrow&lt;&#x2F;code&gt;的变量绑定最大的区别就是，它只是暂时的获得对象的所有权，会在离开作用域或者更换绑定的时候归还。&lt;&#x2F;p&gt;
&lt;p&gt;规则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个引用的生命周期不能比它的拥有者还要长。&lt;&#x2F;li&gt;
&lt;li&gt;你可以有多个引用，但是必须满足：1. 可以有多个引用（&lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;，不可变）；2. 只能有一个可变的引用（&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;lifetime&quot;&gt;Lifetime&lt;&#x2F;h2&gt;
&lt;p&gt;每一个变量都有它自己的生命周期，而生命周期的不同是 &lt;code&gt;danging pointer&lt;&#x2F;code&gt; 发生的主要原因。当你仍然持有一个对象的引用，而这个对象的拥有者的生命周期结束了，那么这个引用就无效了。&lt;&#x2F;p&gt;
&lt;p&gt;所以，Rust 中不会允许这样的事情发生。Rust 通过整个所有权系统的 &lt;em&gt;生命周期&lt;&#x2F;em&gt;（lifetime） 这一概念来实现这个需求。它明确的指出了每一个引用有效的作用域。&lt;&#x2F;p&gt;
&lt;p&gt;当我们定义了一个形参为引用的函数，就涉及到了引用的生命周期。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn foo(x: &amp;amp;i32) {
}
fn foo2&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a i32) {
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的例子中第一个写法省略了引用 &lt;code&gt;x&lt;&#x2F;code&gt; 的生命周期的声明，第二个例子是声明生命周期的显式写法。&lt;&#x2F;p&gt;
&lt;p&gt;这里的写法有点类似于 C++ 中的模板函数，需要先在函数名后面的 &lt;code&gt;&amp;lt;&amp;gt;&lt;&#x2F;code&gt; 中提到所用的生命周期，才能在后面的形参列表或者返回值中用到它。&lt;&#x2F;p&gt;
&lt;p&gt;生命周期并不会改变变量的类型，所以 &lt;code&gt;&amp;amp;i32&lt;&#x2F;code&gt; 和 &lt;code&gt;&amp;amp;&#x27;a i32&lt;&#x2F;code&gt; 拥有同样的类型。&lt;&#x2F;p&gt;
&lt;p&gt;同理，不光函数会涉及到生命周期，含有引用的结构体也会有生命周期的问题，显式声明的写法和函数类似。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Foo&amp;lt;&amp;#x27;a&amp;gt; {
	x:&amp;amp;&amp;#x27;a i32,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;被省略了声明周期的函数会遵循着以下条件推导变量的生命周期：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;每一个被省略的函数参数成为一个不同的生命周期参数；&lt;&#x2F;li&gt;
&lt;li&gt;如果刚好有一个生命周期，不管是否省略，这个生命周期都将成为被省略的返回值的生命周期；&lt;&#x2F;li&gt;
&lt;li&gt;如果有多个生命周期，并且没有 &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; 或者 &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; 的时候，省略返回值的生命周期是不允许的，如果有 &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; 或者 &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; 的话，被省略的返回值的生命周期将是 &lt;code&gt;self&lt;&#x2F;code&gt; 的生命周期。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Ownership&lt;&#x2F;strong&gt;，&lt;strong&gt;Borrow&lt;&#x2F;strong&gt; 和 &lt;strong&gt;Lifetime&lt;&#x2F;strong&gt; 三个部分共同构成了 Rust 的 &lt;strong&gt;Ownership System&lt;&#x2F;strong&gt;。成为了它保证零运行成本的内存安全的关键。这也成为了 Rust 陡峭学习曲线的一个很重要的部分。慢慢熟悉起来之后，会越来越顺手的。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Garbage Collection: Mark-Sweep</title>
            <pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/garbage-collection-mark-sweep/</link>
            <guid>https://twistoy.com/posts/garbage-collection-mark-sweep/</guid>
            <description>&lt;h4 id=&quot;1-2-automatic-dynamic-memory-management&quot;&gt;1.2 Automatic dynamic memory management&lt;&#x2F;h4&gt;
&lt;p&gt;原则上，回收器最终都会将所有不可达对象回收。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;追踪式回收&lt;&#x2F;em&gt; 引入 &lt;strong&gt;垃圾&lt;&#x2F;strong&gt; 这一具有明确判定标准的概念，但它不一定包含所有不再使用的对象。&lt;&#x2F;li&gt;
&lt;li&gt;出于效率原因，某些对象可能不会被回收。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h4 id=&quot;1-3-comparing-garbage-collection-algorithms&quot;&gt;1.3 Comparing garbage collection algorithms&lt;&#x2F;h4&gt;
&lt;p&gt;用什么来衡量各种垃圾回收算法的好坏呢：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;安全性。在任何时候都不能回收活的对象。&lt;&#x2F;li&gt;
&lt;li&gt;吞吐量。**标记 &#x2F; 构造率（mark &#x2F; cons ratio）**来衡量，它表示回收器（对存活对象进行标记）与赋值器（创建或者构造新的链表单元）活跃度的比值。&lt;&#x2F;li&gt;
&lt;li&gt;完整性和及时性。完整性即所有的垃圾被回收的情况，及时性就是垃圾产生之后多久被回收。&lt;&#x2F;li&gt;
&lt;li&gt;停顿时间。在进行垃圾回收的时候中断赋值器线程的时间。【最小赋值器使用率（MMU）和界限赋值器使用率（BMU）的概念，去衡量停顿时间的分布。】&lt;&#x2F;li&gt;
&lt;li&gt;空间开销。&lt;&#x2F;li&gt;
&lt;li&gt;针对结构的特别优化。&lt;&#x2F;li&gt;
&lt;li&gt;可扩展性和可移植性。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;2-1-the-mark-sweep-algorithm&quot;&gt;2.1 The mark-sweep algorithm&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;如果将标记位白存在对象中，那么&lt;code&gt;mark&lt;&#x2F;code&gt;方法处理的将是那些刚刚被标记的对象，因此这些对象可能还在缓存中。那么回收过程的高速缓存相关行文会影响到回收器的性能。&lt;&#x2F;li&gt;
&lt;li&gt;标记-清扫回收器要求堆布局满足一定的条件：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol&gt;
&lt;li&gt;标记-清扫回收器不会移动对象，因此内存管理器必须能够控制堆内存碎片，过多的内存碎片可能会导致分配器无法满足新分配请求，从而增加垃圾回收的频率，甚至于根本无法分配。&lt;&#x2F;li&gt;
&lt;li&gt;清扫器必须能够遍历堆中的每一个对象，不管是否存在一定用于对齐的字节，&lt;code&gt;sweep&lt;&#x2F;code&gt;方法必能够准确的找到下一个对象。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;center&gt;Mark-Sweep: Allocate&lt;&#x2F;center&gt;
&lt;pre&gt;&lt;code&gt;New():
	ref &amp;lt;- allocate()
	if ref == null:
		collect()
		ref &amp;lt;- allocate()
		if ref == null:
			error &amp;quot;Out of memory.&amp;quot;
	return ref
atomic collect():
	markFromRoots()
	sweep(HeapStart, HeapEnd)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;center&gt;Mark-Sweep: Mark&lt;&#x2F;center&gt;
&lt;pre&gt;&lt;code&gt;markFromRoots():
	initialise(work_list)
	for each fld in Roots:
		ref &amp;lt;- *fld
		if ref != null and not isMarked(ref):
			setMarked(ref)
			add(work_list, ref)
			mark()

initialise(work_list):
	work_list &amp;lt;- empty

mark():
	while not isEmpty(work_list):
		ref &amp;lt;- remove(work_list)
		for each fld in Pointers(ref):
			child &amp;lt;- *fld
			if child != null and not isMarked(child):
				setMarked(child)
				add(work_list, child)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;center&gt;Mark-Sweep: Sweep&lt;&#x2F;center&gt;
&lt;pre&gt;&lt;code&gt;sweep(start, end):
	scan &amp;lt;- start
	while scan &amp;lt; end:
		if isMarked(scan):
			unsetMarked(scan)
		else:
			free(scan)
		scan &amp;lt;- nextObject(scan)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;2-4-bitmap-marking&quot;&gt;2.4 Bitmap marking&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;可以应用于保守式回收器（conservative collector）。&lt;&#x2F;li&gt;
&lt;li&gt;减少回收过程中的换页次数。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre&gt;&lt;code&gt;mark():
	cur &amp;lt;- nextInBitmap()
	while cur &amp;lt; HeapEnd:
		add(work_list, cur)
		markStep(cur)
		cur &amp;lt;- nextBitmap()

markStep(start):
	while not isEmpty(work_list):
		ref &amp;lt;- remove(work_list)
		for each fld in Pointers(ref):
			child &amp;lt;- *fld
			if child != null and not isMarked(child):
				setMarked(child)
				if child &amp;lt; start:
					add(work_list, child)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;2-5-lazy-sweeping&quot;&gt;2.5 Lazy sweeping&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;优化清扫阶段高速缓存行为的一种方案是使用对象预取。回收器可以按照固定步幅对大小相同的对象进行清扫。&lt;&#x2F;li&gt;
&lt;li&gt;对象及其标志位存在两个特征：
&lt;ol&gt;
&lt;li&gt;一旦某个对象成为垃圾，它将一直都是垃圾，不可能再被赋值器访问或者复活。&lt;&#x2F;li&gt;
&lt;li&gt;赋值器永远不会访问对象的标记位。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;center&gt;Block structure heep: lazy sweeping&lt;&#x2F;center&gt;
&lt;pre&gt;&lt;code&gt;atomic collect():
	markFromRoots()
	for each block in Blocks:
		if not isMarked(block):
			add(blockAllocator, block)
		else:
			add(reclaimList, block)
atomic allocate(sz):
	result &amp;lt;- remove(sz)
	if result == null:
		lazySweep(sz)
		result &amp;lt;- remove(sz)
	return result

lazySweep(sz):
	repeat
		block &amp;lt;- nextBlock(reclainmList, sz)
		if block != null:
			sweep(start(block), end(block))
			if spaceFound(block):
				return
	until block == null
	allocSlow(sz)

allocSlow(sz):
	block &amp;lt;- allocateBlock()
	if block != null:
		initialise(block, sz)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;2-6-cache-misses-in-the-marking-loop&quot;&gt;2.6 Cache misses in the marking loop&lt;&#x2F;h4&gt;
&lt;center&gt;mark procedure base on FIFO prefetch buffer&lt;&#x2F;center&gt;
&lt;pre&gt;&lt;code&gt;add(work_list, item):
	markStack &amp;lt;- getStack(work_list)
	push(markStack, item)

remove(work_list):
	markStack &amp;lt;- getStack(work_list)
	addr &amp;lt;- pop(markStack)
	prefetch(addr)
	fifo &amp;lt;- getFifo(work_list)
	prepend(fifo, addr)
	return remove(fifo)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;center&gt;Mark edge not node in object graph&lt;&#x2F;center&gt;
&lt;pre&gt;&lt;code&gt;mark():
	while not isEmpty(work_list):
		obj &amp;lt;- remove(work_list)
		if not isMarked(obj):
			setMarked(obj)
			for each fld in Pointers(obj):
				child &amp;lt;- *fld
				if child != null:
					add(work_list, child)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>matplotlib基础</title>
            <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/matplotlib-basic/</link>
            <guid>https://twistoy.com/posts/matplotlib-basic/</guid>
            <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;matplotlib是一个很好用的可以画2D图的Python模块。它提供了很方便进行可视化数据的方案。下面是对matplotlib的使用进行了一个简单的记录。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;simple-plot&quot;&gt;Simple plot&lt;&#x2F;h1&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

X = np.linspace(-np.pi, np.pi, 256,endpoint=True)
C,S = np.cos(X), np.sin(X)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的&lt;code&gt;X&lt;&#x2F;code&gt;是一个数组，里面有256个数，范围是\([-\pi,\pi]\)。接下来的&lt;code&gt;C&lt;&#x2F;code&gt;和&lt;code&gt;S&lt;&#x2F;code&gt;是分别是cos值和sin值。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-chu-hui-tu&quot;&gt;基础绘图&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

X = np.linspace(-np.pi, np.pi, 256, endpoint=True)
C,S = np.cos(X), np.sin(X)

plt.plot(X,C)
plt.plot(X,S)

plt.show()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dui-tu-jin-xing-yi-xie-she-zhi&quot;&gt;对图进行一些设置&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# Imports
import numpy as np
import matplotlib.pyplot as plt

# Create a new figure of size 8x6 points, using 100 dots per inch
plt.figure(figsize=(8,6), dpi=80)

# Create a new subplot from a grid of 1x1
plt.subplot(111)

X = np.linspace(-np.pi, np.pi, 256,endpoint=True)
C,S = np.cos(X), np.sin(X)

# Plot cosine using blue color with a continuous line of width 1 (pixels)
plt.plot(X, C, color=&amp;quot;blue&amp;quot;, linewidth=1.0, linestyle=&amp;quot;-&amp;quot;)

# Plot sine using green color with a continuous line of width 1 (pixels)
plt.plot(X, S, color=&amp;quot;green&amp;quot;, linewidth=1.0, linestyle=&amp;quot;-&amp;quot;)

# Set x limits
plt.xlim(-4.0,4.0)

# Set x ticks
plt.xticks(np.linspace(-4,4,9,endpoint=True))

# Set y limits
plt.ylim(-1.0,1.0)

# Set y ticks
plt.yticks(np.linspace(-1,1,5,endpoint=True))

# Save figure using 72 dots per inch
# savefig(&amp;quot;..&amp;#x2F;figures&amp;#x2F;exercice_2.png&amp;quot;,dpi=72)

# Show result on screen
plt.show()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_2.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gai-bian-yan-se-he-xian-de-cu-xi&quot;&gt;改变颜色和线的粗细&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.figure(figsize=(10,6), dpi=80)
plt.plot(X, C, color=&amp;quot;blue&amp;quot;, linewidth=2.5, linestyle=&amp;quot;-&amp;quot;)
plt.plot(X, S, color=&amp;quot;red&amp;quot;,  linewidth=2.5, linestyle=&amp;quot;-&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;she-zhi-xzhou-he-yzhou-de-fan-wei&quot;&gt;设置X轴和Y轴的范围&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.xlim(X.min()*1.1, X.max()*1.1)
plt.ylim(C.min()*1.1, C.max()*1.1)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_4.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;she-zhi-zuo-biao-zhou-de-ke-du&quot;&gt;设置坐标轴的刻度&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.xticks( [-np.pi, -np.pi&amp;#x2F;2, 0, np.pi&amp;#x2F;2, np.pi])
plt.yticks([-1, 0, +1])
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_5.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;she-zhi-zuo-biao-zhou-ke-du-shang-de-zi&quot;&gt;设置坐标轴刻度上的字&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.xticks([-np.pi, -np.pi&amp;#x2F;2, 0, np.pi&amp;#x2F;2, np.pi],[r&amp;#x27;$-\pi$&amp;#x27;, r&amp;#x27;$-\pi&amp;#x2F;2$&amp;#x27;, r&amp;#x27;$0$&amp;#x27;, r&amp;#x27;$+\pi&amp;#x2F;2$&amp;#x27;, r&amp;#x27;$+\pi$&amp;#x27;])

plt.yticks([-1, 0, +1],[r&amp;#x27;$-1$&amp;#x27;, r&amp;#x27;$0$&amp;#x27;, r&amp;#x27;$+1$&amp;#x27;])
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_6.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-dong-zuo-biao-zhou&quot;&gt;移动坐标轴&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;ax = plt.gca()
ax.spines[&amp;#x27;right&amp;#x27;].set_color(&amp;#x27;none&amp;#x27;)
ax.spines[&amp;#x27;top&amp;#x27;].set_color(&amp;#x27;none&amp;#x27;)
ax.xaxis.set_ticks_position(&amp;#x27;bottom&amp;#x27;)
ax.spines[&amp;#x27;bottom&amp;#x27;].set_position((&amp;#x27;data&amp;#x27;,0))
ax.yaxis.set_ticks_position(&amp;#x27;left&amp;#x27;)
ax.spines[&amp;#x27;left&amp;#x27;].set_position((&amp;#x27;data&amp;#x27;,0))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_7.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wei-tu-tian-jia-shuo-ming&quot;&gt;为图添加说明&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.plot(X, C, color=&amp;quot;blue&amp;quot;, linewidth=2.5, linestyle=&amp;quot;-&amp;quot;, label=&amp;quot;cosine&amp;quot;)
plt.plot(X, S, color=&amp;quot;red&amp;quot;,  linewidth=2.5, linestyle=&amp;quot;-&amp;quot;, label=&amp;quot;sine&amp;quot;)

plt.legend(loc=&amp;#x27;upper left&amp;#x27;, frameon=False)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_8.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tian-jia-zhu-shi&quot;&gt;添加注释&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;t = 2*np.pi&amp;#x2F;3
plt.plot([t,t],[0,np.cos(t)], color =&amp;#x27;blue&amp;#x27;, linewidth=1.5, linestyle=&amp;quot;--&amp;quot;)
plt.scatter([t,],[np.cos(t),], 50, color =&amp;#x27;blue&amp;#x27;)

plt.annotate(r&amp;#x27;$\sin(\frac{2\pi}{3})=\frac{\sqrt{3}}{2}$&amp;#x27;,
             xy=(t, np.sin(t)), xycoords=&amp;#x27;data&amp;#x27;,
             xytext=(+10, +30), textcoords=&amp;#x27;offset points&amp;#x27;, fontsize=16,
             arrowprops=dict(arrowstyle=&amp;quot;-&amp;gt;&amp;quot;, connectionstyle=&amp;quot;arc3,rad=.2&amp;quot;))

plt.plot([t,t],[0,np.sin(t)], color =&amp;#x27;red&amp;#x27;, linewidth=1.5, linestyle=&amp;quot;--&amp;quot;)
plt.scatter([t,],[np.sin(t),], 50, color =&amp;#x27;red&amp;#x27;)

plt.annotate(r&amp;#x27;$\cos(\frac{2\pi}{3})=-\frac{1}{2}$&amp;#x27;,
             xy=(t, np.cos(t)), xycoords=&amp;#x27;data&amp;#x27;,
             xytext=(-90, -50), textcoords=&amp;#x27;offset points&amp;#x27;, fontsize=16,
             arrowprops=dict(arrowstyle=&amp;quot;-&amp;gt;&amp;quot;, connectionstyle=&amp;quot;arc3,rad=.2&amp;quot;))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;matplotlib&#x2F;figures&#x2F;exercice_9.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;see-also&quot;&gt;See also&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;numpy&#x2F;numpy.html&quot;&gt;Numpy&lt;&#x2F;a&gt;
&lt;a href=&quot;http:&#x2F;&#x2F;www.labri.fr&#x2F;perso&#x2F;nrougier&#x2F;teaching&#x2F;numpy.100&#x2F;index.html&quot;&gt;100 Numpy exercises&lt;&#x2F;a&gt;
&lt;a href=&quot;http:&#x2F;&#x2F;journals.plos.org&#x2F;ploscompbiol&#x2F;article?id=10.1371&#x2F;journal.pcbi.1003833&quot;&gt;Ten simple rules for better figures&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>C++ zip实现</title>
            <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/zip-implementtation-for-cpp/</link>
            <guid>https://twistoy.com/posts/zip-implementtation-for-cpp/</guid>
            <description>&lt;p&gt;最近心血来潮想在C++里实现一些像在python里一样好用的小组件，主要是希望充分发挥&lt;code&gt;C++11&lt;&#x2F;code&gt;里&lt;code&gt;for&lt;&#x2F;code&gt;循环的威力。在完成了&lt;code&gt;enumerate&lt;&#x2F;code&gt;之后，在&lt;code&gt;zip&lt;&#x2F;code&gt;的完成上用了比较久的时间。&lt;&#x2F;p&gt;
&lt;p&gt;在这里记录下来自己对&lt;code&gt;zip&lt;&#x2F;code&gt;的简单实现。&lt;&#x2F;p&gt;
&lt;p&gt;主要就用了模板递归，结合了一些&lt;code&gt;C++11&lt;&#x2F;code&gt;的新特性完成的。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#pragma once

namespace twistoy {
	template&amp;lt;typename first, typename... last&amp;gt;
	class zip_iterator {
	public:
		using value_type = std::tuple&amp;lt;typename first::reference, typename last::reference...&amp;gt;;
		using rebind = zip_iterator&amp;lt;first, last...&amp;gt;;
		using sub_iterator = zip_iterator&amp;lt;last...&amp;gt;;
	private:
		first it_;
		sub_iterator sub_it_;
	public:

		zip_iterator(first it, sub_iterator sub_it) : it_(it), sub_it_(sub_it) {}

		rebind&amp;amp; operator++() {
			++it_;
			++sub_it_;
			return *this;
		}

		value_type operator *() {
			return std::tuple_cat(std::tuple&amp;lt;typename first::reference&amp;gt;(*it_), *sub_it_);
		}

		bool operator != (const rebind&amp;amp; others) const {
			return (it_ != others.it_) &amp;amp;&amp;amp; (sub_it_ != others.sub_it_);
		}

	};

	template&amp;lt;typename first&amp;gt;
	class zip_iterator&amp;lt;first&amp;gt; {
	public:
		using value_type = std::tuple&amp;lt;typename first::reference&amp;gt;;
		using rebind = zip_iterator&amp;lt;first&amp;gt;;
	private:
		first it_;
	public:
		zip_iterator(first it) : it_(it) {}
		value_type operator *() {
			return value_type(*it_);
		}
		rebind&amp;amp; operator++() {
			++it_;
			return *this;
		}
		bool operator != (const rebind&amp;amp; others) const {
			return it_ != others.it_;
		}
	};

	template&amp;lt;typename first, typename... last&amp;gt;
	class zip_impl : zip_impl&amp;lt;last...&amp;gt; {
	public:
		using iterator = zip_iterator&amp;lt;typename first::iterator, typename last::iterator...&amp;gt;;
	private:
		first&amp;amp; value_;
	public:
		zip_impl(first&amp;amp; value, last&amp;amp;... args) : value_(value), zip_impl&amp;lt;last...&amp;gt;(args...) {}
		iterator begin() {
			return iterator(value_.begin(), zip_impl&amp;lt;last...&amp;gt;::begin());
		}
		iterator end() {
			return iterator(value_.end(), zip_impl&amp;lt;last...&amp;gt;::end());
		}
	};

	template&amp;lt;typename first&amp;gt;
	class zip_impl&amp;lt;first&amp;gt; {
	public:
		using iterator = zip_iterator&amp;lt;typename first::iterator&amp;gt;;
	private:
		first&amp;amp; value_;
	public:
		zip_impl(first&amp;amp; value) : value_(value) {}
		iterator begin() {
			return iterator(value_.begin());
		}
		iterator end() {
			return iterator(value_.end());
		}
	};

	template&amp;lt;typename... args_t&amp;gt;
	zip_impl&amp;lt;typename std::decay&amp;lt;args_t&amp;gt;::type...&amp;gt; zip(args_t&amp;amp;... args) {
		zip_impl&amp;lt;typename std::decay&amp;lt;args_t&amp;gt;::type...&amp;gt; tmp(args...);
		return tmp;
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>C++ Template</title>
            <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/cpp-template/</link>
            <guid>https://twistoy.com/posts/cpp-template/</guid>
            <description>&lt;h1 id=&quot;han-shu-mo-ban&quot;&gt;函数模板&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;shi-yong-mo-ban&quot;&gt;使用模板&lt;&#x2F;h2&gt;
&lt;p&gt;模板被编译了两次，分别发生在：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;实例化之前，先检查模板代码本身，查看语法是否正确。&lt;&#x2F;li&gt;
&lt;li&gt;在实例化旗舰，检查模板代码，查看是否所有的调用都有效。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;mo-ban-de-tui-dao&quot;&gt;模板的推导&lt;&#x2F;h2&gt;
&lt;p&gt;在模板推导的过程中，不会进行自动的类型转换，每个类型都必须正确的匹配。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
inline T const&amp;amp; max (T const&amp;amp; a, T const&amp;amp; b);

max(4, 7); &amp;#x2F;&amp;#x2F; OK: 两个实参的烈性都是int
max(4, 4.2); &amp;#x2F;&amp;#x2F; ERROR: 第二个实参的类型是double，这里没有把第一个int自动升级成了double
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有三种方法来处理：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;对实参进行强制类型转换，使它们可以相互匹配。&lt;code&gt;max(static_cast&amp;lt;double&amp;gt;(4), 4.2);&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;显示制定T的类型。&lt;code&gt;max&amp;lt;double&amp;gt;(4, 4.2);&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;制定两个参数可以有不同的类型。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;mo-ban-can-shu&quot;&gt;模板参数&lt;&#x2F;h2&gt;
&lt;p&gt;在函数模板内部，不能制定缺省的模板实参。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zhong-zai-han-shu-mo-ban&quot;&gt;重载函数模板&lt;&#x2F;h2&gt;
&lt;p&gt;函数的所有重载版本的声明都应该位于该函数被调用的位置之前。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;lei-mo-ban&quot;&gt;类模板&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;lei-mo-ban-de-te-hua&quot;&gt;类模板的特化&lt;&#x2F;h2&gt;
&lt;p&gt;如果要特化一个类模板，还要特化该类模板的所有成员函数。虽然也可以只特化某个成员函数，但这个做法并没有特化整个类，也就没有特化整个类模板。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ju-bu-te-hua&quot;&gt;局部特化&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
class MyClass&amp;lt;T, T&amp;gt;;

template&amp;lt;typename T&amp;gt;
class MyClass&amp;lt;T, int&amp;gt;;

template&amp;lt;typename T1, typename T2&amp;gt;
class MyClass&amp;lt;T1*, T2*&amp;gt;;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有多个局部特化同等程度的匹配某个声明的时候，那么该声明具有二义性：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;MyClass&amp;lt;int, int&amp;gt; m;
&amp;#x2F;&amp;#x2F; MyClass&amp;lt;T, T&amp;gt;, MyClass&amp;lt;T, int&amp;gt;
MyClass&amp;lt;int*, int*&amp;gt; m;
&amp;#x2F;&amp;#x2F; MyClass&amp;lt;T, T&amp;gt;, MyClass&amp;lt;T1*, T2*&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为了解决第二种二义性，可以提供一个指向相同类型指针的特化：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
class MyClass&amp;lt;T*, T*&amp;gt;;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;que-sheng-mo-ban-shi-can&quot;&gt;缺省模板实参&lt;&#x2F;h2&gt;
&lt;p&gt;像指定一个函数的缺省实参一样。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fei-lei-xing-mo-ban-can-shu&quot;&gt;非类型模板参数&lt;&#x2F;h1&gt;
&lt;p&gt;对于函数模板和类模板，模板参数并不局限于类型，普通纸也可以作为模板参数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fei-lei-xing-mo-ban-can-shu-de-xian-zhi&quot;&gt;非类型模板参数的限制&lt;&#x2F;h2&gt;
&lt;p&gt;非类型模板参数可以是常整数（包括枚举值），或者指向外部链接对象的指针。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;浮点数和类对象&lt;&#x2F;strong&gt; 是不允许作为非类型模板参数的。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ji-qiao-xing-ji-chu-zhi-shi&quot;&gt;技巧性基础知识&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;guan-jian-zi-typename&quot;&gt;关键字 &lt;code&gt;typename&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;当某个依赖于模板参数的名称是一个类型时，就应该使用 &lt;code&gt;typename&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;template-gou-zao&quot;&gt;&lt;code&gt;.template&lt;&#x2F;code&gt; 构造&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;int N&amp;gt;
void printBitset (std::bitset&amp;lt;N&amp;gt; const&amp;amp; bs) {
    std::cout &amp;lt;&amp;lt; bs.template to_string&amp;lt;char, char_traits&amp;lt;char&amp;gt;, allocator&amp;lt;char&amp;gt; &amp;gt;();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用 &lt;code&gt;template&lt;&#x2F;code&gt; 去修饰后面的 &lt;code&gt;to_string&lt;&#x2F;code&gt; 的显式实例化模板版本的 &lt;code&gt;&amp;lt;&lt;&#x2F;code&gt; ，不是数学上的小于号，而是模板实参列表的起始符号。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yong-this&quot;&gt;使用 &lt;code&gt;this-&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;对于具有基类的类模板，自身使用名称 &lt;code&gt;x&lt;&#x2F;code&gt; 并不一定等于 &lt;code&gt;this-&amp;gt;x&lt;&#x2F;code&gt;。即使该 &lt;code&gt;x&lt;&#x2F;code&gt; 是从基类继承获得的。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于那些在基类中声明，并且依赖于模板参数的符号（函数或者变量等），你应该在他们前面使用&lt;code&gt;this-&amp;gt;&lt;&#x2F;code&gt;或者&lt;code&gt;Base&amp;lt;T&amp;gt;::&lt;&#x2F;code&gt;。如果希望完全避免不确定性，你可以限定所有的成员的访问。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;cheng-yuan-mo-ban&quot;&gt;成员模板&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
class Stack {
    ...
    template &amp;lt;typename T2&amp;gt;
    Stack&amp;lt;T&amp;gt;&amp;amp; operator = (Stack&amp;lt;T2&amp;gt; const&amp;amp;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;对于类模板而言，只有被调用的函数才会被实例化。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;mo-ban-de-mo-ban-can-shu&quot;&gt;模板的模板参数&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T, template &amp;lt;typename ELEM&amp;gt; class CONT = std::deque&amp;gt;
class Stack;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;在上面那段代码中第一行的 &lt;code&gt;class&lt;&#x2F;code&gt; 是不能和 &lt;code&gt;typename&lt;&#x2F;code&gt; 互换的，因为这里是为了定义一个类，而不是表示一个类型。&lt;&#x2F;li&gt;
&lt;li&gt;没有用到上面的 &lt;code&gt;ELEM&lt;&#x2F;code&gt; 参数，所以可以省略不写。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;函数模板不支持模板的模板参数。&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;模板的模板实参&lt;&#x2F;strong&gt;必须精确的匹配。匹配时并不会考虑“模板的模板实参”的缺省模板实参。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;mo-ban-de-shi-can-pi-pei&quot;&gt;模板的实参匹配&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T,
            template &amp;lt;typename ELEM,
                        typename ALLOC = std::allocator&amp;lt;ELEM&amp;gt; &amp;gt; class CONT = std::deque&amp;gt;
class Stack;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ling-chu-shi-hua&quot;&gt;零初始化&lt;&#x2F;h2&gt;
&lt;p&gt;希望对所有的对象都用缺省构造函数初始化。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;typename T&amp;gt;
void foo() {
    T x = T();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于类模板，需要把所有数据成员的缺省构造函数在这个类的缺省构造函数中调用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zi-fu-chuan-zuo-wei-han-shu-mo-ban-de-shi-can&quot;&gt;字符串作为函数模板的实参&lt;&#x2F;h2&gt;
&lt;p&gt;由于长度的区别，有些字符串属于不同的数据类型。&lt;code&gt;apple&lt;&#x2F;code&gt; 和 &lt;code&gt;peach&lt;&#x2F;code&gt;，具有相同的类型 &lt;code&gt;char const[6]&lt;&#x2F;code&gt;，然而 &lt;code&gt;tomato&lt;&#x2F;code&gt; 的类型是 &lt;code&gt;char const[7]&lt;&#x2F;code&gt;。如果使用的是引用类型的话，在实例化模板的时候，就会出现类型不同的问题。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;typename T&amp;gt;
inline T const&amp;amp; max (T const&amp;amp; a, T const&amp;amp; b) {
    return a &amp;lt; b ? b : a;
}

::max(&amp;quot;apple&amp;quot;, &amp;quot;peach&amp;quot;); &amp;#x2F;&amp;#x2F; ok
::max(&amp;quot;apple&amp;quot;, &amp;quot;tomato&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是在这里使用非引用类型的参数，就是可以的。因为如果使用非引用类型的参数，在这里会进行一个数组到指针类型的转换（这个转型过程通常被叫做decay）。&lt;&#x2F;p&gt;
&lt;p&gt;字符数组和字符串指针不匹配的问题，根据不同的情况，可以：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用非引用参数，取代引用参数。&lt;strong&gt;（可能会导致无用的拷贝。）&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;进行重载。编写接受引用和非引用参数的两个版本。&lt;strong&gt;（可能导致二义性）&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对具体类型进行重载。&lt;&#x2F;li&gt;
&lt;li&gt;重载数组类型。比如：&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template &amp;lt;typename T, int N, int M&amp;gt;
T const * max (T const (&amp;amp;a)[N], T const (&amp;amp;b)[M]) {
    return a &amp;lt; b ? b : a;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;强制要求应用使用显式的类型转换。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        <item>
            <title>2015 长春站亚洲区 &amp;&amp; 退役总结</title>
            <pubDate>Mon, 19 Oct 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/2015-changchun-regional/</link>
            <guid>https://twistoy.com/posts/2015-changchun-regional/</guid>
            <description>&lt;h2 id=&quot;zai-lu-shang&quot;&gt;在路上&lt;&#x2F;h2&gt;
&lt;p&gt;我居然到去长春比赛之前才知道，哈尔滨居然离长春这么近。【好吧，不要在意我的地理，我一直以为去长春至少要做个飞机什么的呢，23333。没想到残酷的事实告诉我，长春比牡丹江还近66666666。】
去的时候的路上在刷微博的时候，居然发现自己和SDL在一辆车上，找她扯淡扯到了快下车，所以在去的时候的车上也没感到什么痛苦，就一下子到了。
回来的时候我在努力的编故事【hhh，我要给小鲜肉们安利舰娘hhhhh】，偶尔和小伙伴们扯一会，可能是比完赛大家心情都还不错的原因， 气氛也是非常的好，虽然火车时间比去的时候长了一个小时，可是也够开心了啊。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;bin-guan-li&quot;&gt;宾馆里&lt;&#x2F;h2&gt;
&lt;p&gt;老实说，宾馆的条件还是可以的。没什么可吐槽的，唯一算上和宾馆有关的吐槽就应该是不认识路还强行要带路的LCH同学。热身赛回来的时候，他说自己是认得路的，我们也天真的相信了他，结果…&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bi-sai-zhong&quot;&gt;比赛中&lt;&#x2F;h2&gt;
&lt;h4 id=&quot;re-shen-sai&quot;&gt;热身赛&lt;&#x2F;h4&gt;
&lt;p&gt;热身赛一共四道题目，A题很逗比的是一个测试人品的题，官方的说法是要测试一下服务器压力。23333。还真的有人品很好的2次就过了，也是厉害。热身赛做了一小会就跑去玩数独和扫雷了。时至今日，我终于学会了扫雷的玩法，【新技能get！】&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zheng-sai&quot;&gt;正赛&lt;&#x2F;h4&gt;
&lt;p&gt;比赛前就听说了这次比赛的题目数量应该是比较多的，和长老预料的不一样的是这次的题目难度并没有因为题量而降低多少。
比赛开始之后像我们这种队伍就开始紧跟榜单，接连发现了两道水题，F题（1Y&#x2F;25）和L题（1Y&#x2F;20）。这两个题呗我们迅速的A掉了。都是1Y。然而当我们看到了J题的时候，本来标解是Trie的，可是我们第一时间想到的是一个$n^3$的暴力枚举的办法，我显然以为是会TLE的。结果在赛场上GF想到了一个略微优化了一点的方法，抱着如果TLE就再仔细想想的念头尝试了一次，结果WA掉了。这次的WA给了我们很大的信心，调掉了一个小bug就A掉了。2Y&#x2F;76
于此同时的是LFQ在写G题。可是一开始他读错了题意，写完一份DFS之后发现并不能通过样例，重构之后1Y&#x2F;134。
这时候我们已经出了四题了，还算是排在了一个还可以的位置上。在LFQ写G题的时候，我和GF在考虑H题的解法。最开始想了一个按照升序来优化枚举的$n^3$的算法。接连WA了很多发，中间也有够侥幸心理觉得既然J题的都可以水过，那么H题的数据也不会太强吧，然后强行TLE了一次。后来发现了这是一个完全背包的模型，飞快重写了完全背包，一次就通过了，最后6Y&#x2F;252。
在GF写升序优化版本的H题的时候，我和LFQ读了E题，并迅速的发现了这应该是个简单的递推一次，然后分情况求解的过程。在GF的H题WA了在纸面上Debug的时候，写好了E题，过了样例就WA了一发。最开始是以为有精度问题的，判断了精度之后又WA了。最后发现自己在一个很蠢很蠢的地方，我们明明想到也写在纸上了的一个条件并没有写进去，加上特判条件，3Y&#x2F;260。&lt;&#x2F;p&gt;
&lt;p&gt;最后我们的成绩也就以6题收尾的。拿了人生中的第一个ACM金牌吧，说不开心都是假的，不过成绩都是过去的事情了，让自己变得更强才更重要呢。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-shu-yu&quot;&gt;结束语&lt;&#x2F;h2&gt;
&lt;p&gt;以金牌收尾的ACM生涯，我自己看来是已经圆满了的。回忆自己搞算法竞赛的过程，从高中时候搞算法竞赛逃课被老师告诉家长，周围的人都劝我不要在学下去了，耽误了茫茫多的文化课，结果NOIP还是以一个很差的成绩收尾了；到了大学开始搞ACM，从大一的时候参加省赛和东北赛都是二等奖滚粗，到大二和亮哥、学姐一起拿到了亚洲区银牌，省赛开始和放牛组队拿到了奇怪的省赛冠军和东北赛一等奖，到了今天我也已经大三了，也算是得偿所愿吧，终于拿到了一个金牌。想想时间过的还真是快的可以，一晃就在茫茫多的训练中过去了。想一想自己以后会不会轻松一点呢，应该就会有周末了吧，假期也可以出去和小伙伴溜达溜达体验祖国的大好风光了？
要说到学ACM我都收获了什么，首先是收获了一群很棒的小伙伴，其次就是在参加比赛的过程中锻炼和证明了自己的能力吧，我觉得。
好像觉得也没什么可写下去的了，就这样吧。我终于有一天退役了，以前看着别人的退役贴都感觉好厉害，今天自己也躺在床上写下了这个不算退役贴的退役贴吧。就这样吧，再见ACM！&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>2015 省赛、东北赛总结</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/2015-provience-and-northeast-contest-summary/</link>
            <guid>https://twistoy.com/posts/2015-provience-and-northeast-contest-summary/</guid>
            <description>&lt;h1 id=&quot;part1-sheng-sai&quot;&gt;Part1. 省赛&lt;&#x2F;h1&gt;
&lt;p&gt;先来吐槽下工大，热身赛之前大家都在外面站着连个休息的地方都没有，整个人都被冻傻了…正赛那天早上还好（其实我感觉主要是天比较给力，比较暖和，也可能是我机智的穿上了棉袄的原因…2333。）&lt;br &#x2F;&gt;
然后就是题目的部分了，所有题目主要就是题面比较难读吧，绝对是的。我们一致认为着出题人的英语绝对有问题，然后脑洞有点大…（绝对脑洞巨大…）&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;ul&gt;
&lt;li&gt;A题，直到现在我依旧没能看懂题目在说什么，如何通过题面得到样例的…&lt;&#x2F;li&gt;
&lt;li&gt;B题，大概貌似是一个贪心吧，我们队按照这个思路写了挺长时间的，，然后WA了，，感觉小问题小坑很多…&lt;&#x2F;li&gt;
&lt;li&gt;C题，我们队也开了，主要是前面三个小时就已经A了五个题了，后面就一起开了B题和C题，结果都坑掉了。 题目大概是说一个连连看，当前状态有多少种合法的选择消去的方案。暴力的用优先队列+BFS尝试了一下，结果T掉了。&lt;&#x2F;li&gt;
&lt;li&gt;D题，其实是一个很简单的贪心啦，题意上面也没有什么难度和坑。很容易1A，我记得。&lt;&#x2F;li&gt;
&lt;li&gt;E题，这道题我读题意读了挺长时间的，然后样例上还有点小问题。（英语太烂23333）读懂题意以后也会很简单的。&lt;&#x2F;li&gt;
&lt;li&gt;F题，我们队用的方法是数位DP，当然由于数据范围的关系暴力好像也是可以过的。&lt;&#x2F;li&gt;
&lt;li&gt;G题，这道题真正的坑点在脑洞上…我至今都是这么认为的。虽然这道题是我们夺冠的关键，，，但是依旧改变不了这是一个脑洞题的事实。只要记得，并不是一个联通块周围有白子和黑子是一人0.5，而是按照白子和黑子的个数按权分配的！就可以了。&lt;&#x2F;li&gt;
&lt;li&gt;H题，斗地主，给你三家牌，问第一家能不能春天…并没有仔细的思考下去…&lt;&#x2F;li&gt;
&lt;li&gt;I题，给三张牌算得分，很简单的模拟。&lt;&#x2F;li&gt;
&lt;li&gt;J题，裸的二分图匹配。WA了一次居然是因为数组忘记清空了…23333。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;如实的说，能夺冠这件事完全就是恰好我们的脑洞开到了出题人的脑洞上去，和我们队本来的实力没有那么大的关系。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;part2-dong-bei-sai&quot;&gt;Part2. 东北赛&lt;&#x2F;h1&gt;
&lt;p&gt;到了东北赛感觉好了很多啊，进门也不要排队了，也不要在外面傻傻的冻着了。顿觉幸福…&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A题，水题不多说。1A。&lt;&#x2F;li&gt;
&lt;li&gt;B题，二维树状数组模板。1A。&lt;&#x2F;li&gt;
&lt;li&gt;C题，题意是说求一个三角形结构中选k个的最大权。读到这道题的时候，我们还在卡着其他的两个题，所以就没有多想下去，而且那么时间想下去也不知道能不能想出来…&lt;&#x2F;li&gt;
&lt;li&gt;D题，类似树形DP的东西，没什么坑点。1A。&lt;&#x2F;li&gt;
&lt;li&gt;E题，说道E题就要说，我很愧对我的高数和大物老师，嗯…还有我高中的数学老师。思路卡了一次，错了一次，然后才发现应该如何的简单处理，最后还卡了一下精度处理上。傻的不行…&lt;&#x2F;li&gt;
&lt;li&gt;F题，没读，现在写总结的时候，，也不想读。&lt;&#x2F;li&gt;
&lt;li&gt;G题，对x做质因子分解求出所有的质因子，然后对于每一个查询m，只要做一个优先队列+BFS就可以了。因为只会找第5个大的。所以结果会很少的。WA了几次都WA在了重复数字的处理上。处理掉了就没问题了。&lt;&#x2F;li&gt;
&lt;li&gt;H题，很简单的一个BFS，坑在了起点就在一个除了1之外的触发器上。嗯…由于忘记了这里，WA了一个半小时。&lt;&#x2F;li&gt;
&lt;li&gt;I题，水题。最开始数据错了，应该是，最后rejudge了，不过也听说有好多小伙伴被坑了。&lt;&#x2F;li&gt;
&lt;li&gt;J题，同F。&lt;&#x2F;li&gt;
&lt;li&gt;K题，我们最后时刻在写的五子棋的问题。我们的想法就是对于有人胜利的情况，来判断局面是否合法，方法就是尝试删掉每一个棋子，看会不会让整个棋局上没有人胜利了，如果有这样的棋子，那么就代表是合法的，否则就不合法。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;总结起来我们一共过了7个题，在7个题里好像也不算速度很快的，要不排名还能再上升一些的。感觉这次比较还是比较能反映出我们队的水平吧。&lt;br &#x2F;&gt;
在比赛里也学到了好多东西，嗯…亮哥说比完赛要去实习了，祝亮哥实习愉快喽~&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>c++11 完美转发+变长参数</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/c-11-perfect-forward/</link>
            <guid>https://twistoy.com/posts/c-11-perfect-forward/</guid>
            <description>&lt;p&gt;&lt;strong&gt;完美转发&lt;&#x2F;strong&gt;(argument forwarding):&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个函数&lt;code&gt;F(a1, a2, ..., an)&lt;&#x2F;code&gt;，要写一个函数G，接受和F相同的参数并传递给F。&lt;br &#x2F;&gt;
这里有三点要求：&lt;br &#x2F;&gt;
1. 能用F的地方，G也一定能用。&lt;br &#x2F;&gt;
2. 不能用F的敌方，G也一定不能用。&lt;br &#x2F;&gt;
3. 转发的开销应该是线性增长的。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这里在C++11出现之前，人们做了很多尝试。就出现了很多的替代方案，直到C++11出现之后，才有了一个完美的解决方案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fei-chang-liang-zuo-zhi-yin-yong-zhuan-fa&quot;&gt;非常量左值引用转发&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void g(T1&amp;amp; t) {
        return f(t);
    }
    
    void f(int t) {}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里不能传入&lt;strong&gt;非常量右值&lt;&#x2F;strong&gt;（&lt;code&gt;g(1)&lt;&#x2F;code&gt;）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chang-liang-zuo-zhi-yin-yong&quot;&gt;常量左值引用&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void g(const T1&amp;amp; t) {
        return f(t);
    }
    
    void f(int&amp;amp; t) {}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;常量左值引用在这里也挂掉了，这里函数_g_是没法把常量左值引用传递给非常量左值引用的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fei-chang-liang-zuo-zhi-yin-yong-chang-liang-zuo-zhi-yin-yong&quot;&gt;非常量左值引用+常量左值引用&lt;&#x2F;h3&gt;
&lt;p&gt;这种方案就是给每个参数写常量左值和非常量左值两个版本的，这个方案的重载函数个数是指数型增长的，在参数多的时候会挂掉的。而且，在传入非常量参数的时候，可能会引发二义性。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chang-liang-zuo-zhi-yin-yong-const-cast&quot;&gt;常量左值引用+const_cast&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;class T&amp;gt;
    void g(const T&amp;amp; t) {
        return f(const_cast&amp;lt;T&amp;amp;&amp;gt;(t));
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里看起来好像解决了方案2里的问题。可是这种转发变量被修改了，不是我们想要的结果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fei-chang-liang-zuo-zhi-yin-yong-xiu-gai-de-can-shu-tui-dao-gui-ze&quot;&gt;非常量左值引用+修改的参数推导规则&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void f(T&amp;amp; t){
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; std::endl;
    }
    
    void f(const long &amp;amp;){
        std::cout &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; std::endl;
    }
    
    int main(){
        f(5);&amp;#x2F;&amp;#x2F; prints 2 under the current rules, 1 after the change
        int const n(5);
        f(n);&amp;#x2F;&amp;#x2F; 1 in both cases
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里会对原有代码有破坏。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;you-zhi-yin-yong&quot;&gt;右值引用&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void g(T&amp;amp;&amp;amp; t) {
        return f(t);
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里不能g不能接受一个左值，因为不能把一个左值传递给一个右值引用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;you-zhi-yin-yong-xiu-gai-de-can-shu-tui-dao-gui-ze-zhuan-fa&quot;&gt;右值引用+修改的参数推导规则转发&lt;&#x2F;h3&gt;
&lt;p&gt;引用叠加原则：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;TR的类型定义&lt;&#x2F;th&gt;&lt;th&gt;声明v的类型&lt;&#x2F;th&gt;&lt;th&gt;v的实际类型&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;T&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;TR&lt;&#x2F;td&gt;&lt;td&gt;A&amp;amp;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;TR&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;A&amp;amp;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;TR&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;A&amp;amp;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;TR&lt;&#x2F;td&gt;&lt;td&gt;A&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;TR&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;A&amp;amp;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;TR&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;td&gt;A&amp;amp;&amp;amp;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;这里如果只去修改对右值引用推导规则，这样就避免对原有的代码的破坏。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;typename T&amp;gt;
    void g(T&amp;amp;&amp;amp; t) {
        return f(std::forward&amp;lt;T&amp;gt;(t));
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里已经可以处理好转发部分了。可是我还是不满意，我希望可以更完美一点，就是无论什么参数，多少参数都可以。这里要结合C++11的变长参数模板来完成。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;typename... Args&amp;gt;
    void g(Args... arg) {
        return f(std::forward(arg)...);
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里包括了变长参数包的展开，这里还可以用&lt;code&gt;sizeof...(Args)&lt;&#x2F;code&gt;来获取变长参数的个数。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6486432&#x2F;variadic-template-templates-and-perfect-forwarding&quot;&gt;c++ - How would one call std::forward on all arguments in a variadic function? - Stack Overflow&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6829241&#x2F;perfect-forwarding-whats-it-all-about&quot;&gt;c++11 - Perfect forwarding - what&#x27;s it all about? - Stack Overflow&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6486432&#x2F;variadic-template-templates-and-perfect-forwarding&quot;&gt;c++ - Variadic template templates and perfect forwarding - Stack Overflow&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2002&#x2F;n1385.htm&quot;&gt;The Forwarding Problem: Arguments&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;C%2B%2B11#.E5.8F.B3.E5.80.BC.E5.BC.95.E7.94.A8.E5.92.8Cmove.E8.AA.9E.E6.84.8F&quot;&gt;C++11维基百科&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>cJSON代码阅读（parse）部分</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/cjson-code-reading-parser/</link>
            <guid>https://twistoy.com/posts/cjson-code-reading-parser/</guid>
            <description>&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;static const char *skip(const char *in) {
  while (in &amp;amp;&amp;amp; *in &amp;amp;&amp;amp; (unsigned char)*in&amp;lt;=32) in++;
  return in;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;跳过&lt;strong&gt;空白字符&lt;&#x2F;strong&gt;。空白字符即ASCII小于等于32的字符。（我还特意查了ascii的表…）。&lt;em&gt;这里我可能会用isspace（掩面逃…）&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre&gt;&lt;code&gt;    static const char *parse_value(cJSON *item,const char *value)
    {
        if (!value)                     return 0;
        if (!strncmp(value,&amp;quot;null&amp;quot;,4))   { item-&amp;gt;type=cJSON_NULL;  return value+4; }
        if (!strncmp(value,&amp;quot;false&amp;quot;,5))  { item-&amp;gt;type=cJSON_False; return value+5; }
        if (!strncmp(value,&amp;quot;true&amp;quot;,4))   { item-&amp;gt;type=cJSON_True; item-&amp;gt;valueint=1;  return value+4; }
        if (*value==&amp;#x27;\&amp;quot;&amp;#x27;)               { return parse_string(item,value); }
        if (*value==&amp;#x27;-&amp;#x27; || (*value&amp;gt;=&amp;#x27;0&amp;#x27; &amp;amp;&amp;amp; *value&amp;lt;=&amp;#x27;9&amp;#x27;))    { return parse_number(item,value); }
        if (*value==&amp;#x27;[&amp;#x27;)                { return parse_array(item,value); }
        if (*value==&amp;#x27;{&amp;#x27;)                { return parse_object(item,value); }
    
        ep=value;return 0;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里是parser的核心。判断该读入的元素类型。null，true，false这三个简单类型可以直接处理。其他的分别交给parse_number，parse_array和parse_object处理。ep是这里用于错误处理的指针，当出错的时候，ep指针里保存的就是当前出现错误的位置。&lt;&#x2F;p&gt;
&lt;p&gt;首先是parse_string部分：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
    static const char *parse_string(cJSON *item,const char *str)
    {
        const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
        if (*str!=&amp;#x27;\&amp;quot;&amp;#x27;) {ep=str;return 0;}
    
        while (*ptr!=&amp;#x27;\&amp;quot;&amp;#x27; &amp;amp;&amp;amp; *ptr &amp;amp;&amp;amp; ++len) if (*ptr++ == &amp;#x27;\\&amp;#x27;) ptr++;
    
        out=(char*)cJSON_malloc(len+1);
        if (!out) return 0;
    
        ptr=str+1;ptr2=out;
        while (*ptr!=&amp;#x27;\&amp;quot;&amp;#x27; &amp;amp;&amp;amp; *ptr)
        {
            if (*ptr!=&amp;#x27;\\&amp;#x27;) *ptr2++=*ptr++;
            else
            {
                ptr++;
                switch (*ptr)
                {
                    case &amp;#x27;b&amp;#x27;: *ptr2++=&amp;#x27;\b&amp;#x27;; break;
                    case &amp;#x27;f&amp;#x27;: *ptr2++=&amp;#x27;\f&amp;#x27;; break;
                    case &amp;#x27;n&amp;#x27;: *ptr2++=&amp;#x27;\n&amp;#x27;; break;
                    case &amp;#x27;r&amp;#x27;: *ptr2++=&amp;#x27;\r&amp;#x27;; break;
                    case &amp;#x27;t&amp;#x27;: *ptr2++=&amp;#x27;\t&amp;#x27;; break;
                    case &amp;#x27;u&amp;#x27;:
                        uc=parse_hex4(ptr+1);ptr+=4;
    
                        if ((uc&amp;gt;=0xDC00 &amp;amp;&amp;amp; uc&amp;lt;=0xDFFF) || uc==0)    break;
    
                        if (uc&amp;gt;=0xD800 &amp;amp;&amp;amp; uc&amp;lt;=0xDBFF)
                        {
                            if (ptr[1]!=&amp;#x27;\\&amp;#x27; || ptr[2]!=&amp;#x27;u&amp;#x27;)    break;
                            uc2=parse_hex4(ptr+3);ptr+=6;
                            if (uc2&amp;lt;0xDC00 || uc2&amp;gt;0xDFFF)       break;
                            uc=0x10000 + (((uc&amp;amp;0x3FF)&amp;lt;&amp;lt;10) | (uc2&amp;amp;0x3FF));
                        }
    
                        len=4;if (uc&amp;lt;0x80) len=1;else if (uc&amp;lt;0x800) len=2;else if (uc&amp;lt;0x10000) len=3; ptr2+=len;
    
                        switch (len) {
                            case 4: *--ptr2 =((uc | 0x80) &amp;amp; 0xBF); uc &amp;gt;&amp;gt;= 6;
                            case 3: *--ptr2 =((uc | 0x80) &amp;amp; 0xBF); uc &amp;gt;&amp;gt;= 6;
                            case 2: *--ptr2 =((uc | 0x80) &amp;amp; 0xBF); uc &amp;gt;&amp;gt;= 6;
                            case 1: *--ptr2 =(uc | firstByteMark[len]);
                        }
                        ptr2+=len;
                        break;
                    default:  *ptr2++=*ptr; break;
                }
                ptr++;
            }
        }
        *ptr2=0;
        if (*ptr==&amp;#x27;\&amp;quot;&amp;#x27;) ptr++;
        item-&amp;gt;valuestring=out;
        item-&amp;gt;type=cJSON_String;
        return ptr;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;首先是遍历了一次整个string，统计出一共的字符个数，存在了len里，中间遇到转义的部分跳过了后面的字符。个数统计好之后，申请内存。这里的&lt;code&gt;cJSON_malloc&lt;&#x2F;code&gt;就是原本的&lt;code&gt;malloc&lt;&#x2F;code&gt;。在这个函数的定义出可以找到：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    static void *(*cJSON_malloc)(size_t sz) = malloc;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;重新从头遍历整个string，不转义的部分是不用处理的。需要特殊处理的就是转义的部分，其实这部分也只有utf-16到utf-8的编码转换问题。（这里的magic number实在是太多了，我还没不知道utf-16和utf-8的编码方式。实在是看不懂了。）&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    static const char *parse_number(cJSON *item,const char *num)
    {
        double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
    
        if (*num==&amp;#x27;-&amp;#x27;) sign=-1,num++;
        if (*num==&amp;#x27;0&amp;#x27;) num++;
        if (*num&amp;gt;=&amp;#x27;1&amp;#x27; &amp;amp;&amp;amp; *num&amp;lt;=&amp;#x27;9&amp;#x27;) do  n=(n*10.0)+(*num++ -&amp;#x27;0&amp;#x27;);   while (*num&amp;gt;=&amp;#x27;0&amp;#x27; &amp;amp;&amp;amp; *num&amp;lt;=&amp;#x27;9&amp;#x27;);
        if (*num==&amp;#x27;.&amp;#x27; &amp;amp;&amp;amp; num[1]&amp;gt;=&amp;#x27;0&amp;#x27; &amp;amp;&amp;amp; num[1]&amp;lt;=&amp;#x27;9&amp;#x27;) {num++;        do  n=(n*10.0)+(*num++ -&amp;#x27;0&amp;#x27;),scale--; while (*num&amp;gt;=&amp;#x27;0&amp;#x27; &amp;amp;&amp;amp; *num&amp;lt;=&amp;#x27;9&amp;#x27;);}
        if (*num==&amp;#x27;e&amp;#x27; || *num==&amp;#x27;E&amp;#x27;)
        {   num++;if (*num==&amp;#x27;+&amp;#x27;) num++; else if (*num==&amp;#x27;-&amp;#x27;) signsubscale=-1,num++;
            while (*num&amp;gt;=&amp;#x27;0&amp;#x27; &amp;amp;&amp;amp; *num&amp;lt;=&amp;#x27;9&amp;#x27;) subscale=(subscale*10)+(*num++ - &amp;#x27;0&amp;#x27;);
        }
    
        n=sign*n*pow(10.0,(scale+subscale*signsubscale));
    
        item-&amp;gt;valuedouble=n;
        item-&amp;gt;valueint=(int)n;
        item-&amp;gt;type=cJSON_Number;
        return num;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里数字的处理就简单很多了。 sign表示有没有负号，如果有的话sign是-1，否则sign为1。&lt;br &#x2F;&gt;
去掉前导0之后，读入每位存在n里。 发现有&amp;quot;.&amp;quot;，并且下一位是数字的话，就说明这是一个小数，开始读入小数点之后的部分。这里用scale来表示当前的数的小数点应该向左移动几位。（这样是不是也同样保证了精度呢？） 读入E，科学计数法表示。处理方式和前面一样。 最后计算出n就可以了。这里把浮点数和整数放在一起处理了。只要在最后valueint只取n的整数部分就可以了。（我自己尝试实现的时候，把整数和小数分开读的，在存类型的时候也尝试把他们分开了。）这种方式需要在输出的时候做一个特殊处理，判断一下valuedouble和valueint之间的差，如果小于给定的eps那就认为这个数字是一个整数，否则认为是小数。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    static const char *parse_array(cJSON *item,const char *value)
    {
        cJSON *child;
        if (*value!=&amp;#x27;[&amp;#x27;)    {ep=value;return 0;}
    
        item-&amp;gt;type=cJSON_Array;
        value=skip(value+1);
        if (*value==&amp;#x27;]&amp;#x27;) return value+1;
    
        item-&amp;gt;child=child=cJSON_New_Item();
        if (!item-&amp;gt;child) return 0;
        value=skip(parse_value(child,skip(value)));
        if (!value) return 0;
    
        while (*value==&amp;#x27;,&amp;#x27;)
        {
            cJSON *new_item;
            if (!(new_item=cJSON_New_Item())) return 0;
            child-&amp;gt;next=new_item;new_item-&amp;gt;prev=child;child=new_item;
            value=skip(parse_value(child,skip(value+1)));
            if (!value) return 0;
        }
    
        if (*value==&amp;#x27;]&amp;#x27;) return value+1;
        ep=value;return 0;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来是关于数组的处理。和其他时候一样，先判断起始字符合法性。然后重复： 1. 新建cJSON对象&lt;br &#x2F;&gt;
2. 读掉空白字符&lt;br &#x2F;&gt;
3. 读入这个对象&lt;br &#x2F;&gt;
4. 读掉空白字符&lt;br &#x2F;&gt;
5. 判断这个字符是否是“,“。如果是，转到1，如果不是判断结尾字符合法性，退出。&lt;br &#x2F;&gt;
数组里面的元素，是用了一个双向链表实现的。具体的定义在cJSON这个结构体的定义处给出了。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    static const char *parse_object(cJSON *item,const char *value)
    {
        cJSON *child;
        if (*value!=&amp;#x27;{&amp;#x27;)    {ep=value;return 0;}
    
        item-&amp;gt;type=cJSON_Object;
        value=skip(value+1);
        if (*value==&amp;#x27;}&amp;#x27;) return value+1;
    
        item-&amp;gt;child=child=cJSON_New_Item();
        if (!item-&amp;gt;child) return 0;
        value=skip(parse_string(child,skip(value)));
        if (!value) return 0;
        child-&amp;gt;string=child-&amp;gt;valuestring;child-&amp;gt;valuestring=0;
        if (*value!=&amp;#x27;:&amp;#x27;) {ep=value;return 0;}
        value=skip(parse_value(child,skip(value+1)));
        if (!value) return 0;
    
        while (*value==&amp;#x27;,&amp;#x27;)
        {
            cJSON *new_item;
            if (!(new_item=cJSON_New_Item()))   return 0;
            child-&amp;gt;next=new_item;new_item-&amp;gt;prev=child;child=new_item;
            value=skip(parse_string(child,skip(value+1)));
            if (!value) return 0;
            child-&amp;gt;string=child-&amp;gt;valuestring;child-&amp;gt;valuestring=0;
            if (*value!=&amp;#x27;:&amp;#x27;) {ep=value;return 0;}
            value=skip(parse_value(child,skip(value+1)));
            if (!value) return 0;
        }
    
        if (*value==&amp;#x27;}&amp;#x27;) return value+1;
        ep=value;return 0;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最后有关于parse的就是关于object对象的parse了。常规的判断其实字符，读掉空白字符。这里先判断了一次结束字符来看是不是空的。 因为一旦有了元素之后，在判断下一个元素是否存在的时候，判断的条件就变成了“,”。这部分在数组中有一样的处理。 这里整体的过程其实和数组的区别只在读入单个元素的方法上： 先读入一个string，读冒号“:”，读value。然后每个child的属性里的string部分保存了这个value的名字。（这里这个保存方式，是不是在get的时候的效率会出现问题呢。感觉这里如果多处理一点，对string串做一个hash可能效果会好一点。）&lt;&#x2F;p&gt;
&lt;p&gt;这样parse细节的部分就都看完了。cJSON_Parse函数是对cJSON_ParseWithOpts的一个封装。cJSON_ParseWithOpts函数处理了读入一个value之外的就是判断了是否需要null作为结束，和返回值存到哪里的问题。代码也很简单：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
    {
        const char *end=0;
        cJSON *c=cJSON_New_Item();
        ep=0;
        if (!c) return 0;
    
        end=parse_value(c,skip(value));
        if (!end)   {cJSON_Delete(c);return 0;}
    
        if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
        if (return_parse_end) *return_parse_end=end;
        return c;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>编译时期计算数组</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/compute-array-in-compile-time/</link>
            <guid>https://twistoy.com/posts/compute-array-in-compile-time/</guid>
            <description>&lt;pre&gt;&lt;code&gt;    #include &amp;lt;iostream&amp;gt;
    #include &amp;lt;array&amp;gt;
    using namespace std;
    
    constexpr int N = 1000000;
    constexpr int f(int x) { return x*2; }
    
    typedef array&amp;lt;int, N&amp;gt; A;
    
    template&amp;lt;int... i&amp;gt; constexpr A fs() { return A{{ f(i)... }}; }
    
    template&amp;lt;int...&amp;gt; struct S;
    
    template&amp;lt;int... i&amp;gt; struct S&amp;lt;0,i...&amp;gt;
    { static constexpr A gs() { return fs&amp;lt;0,i...&amp;gt;(); } };
    
    template&amp;lt;int i, int... j&amp;gt; struct S&amp;lt;i,j...&amp;gt;
    { static constexpr A gs() { return S&amp;lt;i-1,i,j...&amp;gt;::gs(); } };
    
    constexpr auto X = S&amp;lt;N-1&amp;gt;::gs();
    
    int main()
    {
            cout &amp;lt;&amp;lt; X[3] &amp;lt;&amp;lt; endl;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在编译时期计算一个数组里面的元素，这种方法在\(N\)较大的时候会出现&lt;code&gt;constexpr&lt;&#x2F;code&gt;递归深度较大的问题。这种线性的求法似乎不能很好的处理当\(N\)较大的情况。所以这时候可以通过二分所求的\(N\)来解决这个问题。这样最大的递归深度就从\(N\)变成了\(logN\)了。 排名第一的回答中代码是这样写的：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    template&amp;lt;class T&amp;gt; using Invoke = typename T::type;
    
    template&amp;lt;unsigned...&amp;gt; struct seq{ using type = seq; };
    
    template&amp;lt;class S1, class S2&amp;gt; struct concat;
    
    template&amp;lt;unsigned... I1, unsigned... I2&amp;gt;
    struct concat&amp;lt;seq&amp;lt;I1...&amp;gt;, seq&amp;lt;I2...&amp;gt;&amp;gt;
      : seq&amp;lt;I1..., (sizeof...(I1)+I2)...&amp;gt;{};
    
    template&amp;lt;class S1, class S2&amp;gt;
    using Concat = Invoke&amp;lt;concat&amp;lt;S1, S2&amp;gt;&amp;gt;;
    
    template&amp;lt;unsigned N&amp;gt; struct gen_seq;
    template&amp;lt;unsigned N&amp;gt; using GenSeq = Invoke&amp;lt;gen_seq&amp;lt;N&amp;gt;&amp;gt;;
    
    template&amp;lt;unsigned N&amp;gt;
    struct gen_seq : Concat&amp;lt;GenSeq&amp;lt;N&amp;#x2F;2&amp;gt;, GenSeq&amp;lt;N - N&amp;#x2F;2&amp;gt;&amp;gt;{};
    
    template&amp;lt;&amp;gt; struct gen_seq&amp;lt;0&amp;gt; : seq&amp;lt;&amp;gt;{};
    template&amp;lt;&amp;gt; struct gen_seq&amp;lt;1&amp;gt; : seq&amp;lt;0&amp;gt;{};
    
    &amp;#x2F;&amp;#x2F; example
    
    template&amp;lt;unsigned... Is&amp;gt;
    void f(seq&amp;lt;Is...&amp;gt;);
    
    int main(){
      f(gen_seq&amp;lt;6&amp;gt;());
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;原文： &lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13072359&#x2F;c11-compile-time-array-with-logarithmic-evaluation-depth&quot;&gt;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13072359&#x2F;c11-compile-time-array-with-logarithmic-evaluation-depth&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Link Cut Tree</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/link-cut-tree-learning/</link>
            <guid>https://twistoy.com/posts/link-cut-tree-learning/</guid>
            <description>&lt;p&gt;动态树（Dynamic Tree Problems）是一类要动态维护森林连通性问题的总称。一般要维护森林中某个点到根结点的某些数据，应该支持一棵树切割成两棵树，或者两棵树合并成一棵树的操作。而解决这一类问题的基础数据结构就是LCT。&lt;&#x2F;p&gt;
&lt;p&gt;整体维护的过程有点类似于树链剖分的维护过程，不过树链剖分里维护的重链由于是静态的，可以用线段树去维护。对于动态的，我们可以用splay来维护。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structure&quot;&gt;Structure&lt;&#x2F;h2&gt;
&lt;p&gt;我们用操作&lt;code&gt;access(x)&lt;&#x2F;code&gt;来表示访问节点x。那么定义：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Preferred Child&lt;&#x2F;strong&gt;：对于一个节点P，如果最后被访问的节点x在以其子节点Q为根的子树中，那么就称Q为P的_Preferred Child_。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Preferred Edge&lt;&#x2F;strong&gt;：每个点到自己的Preferred Child之间的边，叫做_Preferred Edge_。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Preferred Path&lt;&#x2F;strong&gt;：由Preferred Edge组成的一条不可延伸的路径，叫做_Preferred Path_。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这样我们发现，每个点仅会属于一个preferred path。这样，一棵树就可以由几个preferred path来表示。对于每个preferred path，我们都维护一个splay，维护和的key值，就是每个点在preferred path中的深度。我们把这个splay称作：&lt;em&gt;Auxiliary Tree&lt;&#x2F;em&gt;（辅助树？这名字好难听……）。每个辅助树的根节点都保存着和上一个辅助树的哪一个点是相连的，这个指向被称作：path-parent pointer。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;operations&quot;&gt;Operations&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;access&quot;&gt;access&lt;&#x2F;h3&gt;
&lt;p&gt;当我们访问了节点_v_之后，它将没有preferred child，并且应该是一条preferred path的最后一个节点（at the end of the path）。在我们的辅助树中节点都是按照深度排序的，也就是说，这时候所有在点_v_右侧的点都是应该被断开的。这个操作在splay上是很容易的。我们只要对_v_做一次splay操作，把它转到根节点上，然后断开它的右子树，然后右子树的根的path-parent pointer指向_v_就可以了。&lt;br &#x2F;&gt;
然后我们继续向上遍历直到这条path的根，调整需要调整的部分。我们只要跟着path-parent pointer走就可以了，因为_v_节点现在是根了。这一定是有序的。如果我们发现当前点不是根的话，我们会顺着path-parent pointer走到另一条path上的一个点_w_上。接下来，我们对_w_进行一次splay，然后断掉它的右子树，维护这个右子树的path-parent pointer。然后把_v_放在_w_右子树的位置上。（这里相当于把两个splay合并起来了。可以合并的原因是因为所有在_v_所在的辅助树里的点的深度都应该比_w_大。因为一直的有序可以保证这一点。）对_v_再做一次splay。重复这个过程，直到我们走到了根上。&lt;&#x2F;p&gt;
&lt;p&gt;PS：这里都用&lt;code&gt;child[x][0]&lt;&#x2F;code&gt;来表示x的左子树，&lt;code&gt;child[x][1]&lt;&#x2F;code&gt;来表示x的右子树。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    int access(int x) {
        int y = 0;
        do {
            splay(x);
            root[child[x][1]] = true;
            root[child[x][1] = y] = false;
            pushUp(x);
            x = father[y = x];
        } while(x);
        return y;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;findroot&quot;&gt;FindRoot&lt;&#x2F;h3&gt;
&lt;p&gt;_FindRoot_操作用来寻找点_v_在所在树的根节点。这个操作很简单，我们只要对_v_做一次access操作，这样_v_和它的根就应该在一个splay中了。那么此时的根就应该是这个splay最左边的节点。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cut&quot;&gt;Cut&lt;&#x2F;h3&gt;
&lt;p&gt;断掉_v_和其父亲节点之间的边。首先access节点_v_。然后讲_v_旋转到所在辅助树的根节点上。断掉左子树。维护好path-parent pointer就可以了。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    void cut(int v) {
        access(v);
        splay(v);
        father[child[v][0]] = 0;
        root[child[v][0]] = true;
        child[v][0] = 0;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;PS：如果要断掉两个点之间的边呢？会比这个麻烦一点。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    void cut(int u, int v) {
        access(u);
        splay(u);
        reserse(u);
        access(v);
        splay(v);
        father[child[v][0]] = father[v];
        father[v] = 0;
        root[child[v][0]] = true;
        child[v][0] = 0;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;link&quot;&gt;Link&lt;&#x2F;h3&gt;
&lt;p&gt;如果_v_是一个树的根，而_w_是另一个树里的点的话。只要让_w_成为_v_的父亲。我们可以同时对_w_和_v_都做一次access操作。让_w_成为_v_的左子树。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    void link(int u, int v) {
        access(u);
        splay(u);
        reverse(child[u][0]);
        access(v);
        splay(v);
        child[v][1] = u;
        father[u] = v;
        root[u] = false;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是一个例题。（我才不会说我是看到这道题才来学的LCT呢…）&lt;br &#x2F;&gt;
&lt;a href=&quot;http:&#x2F;&#x2F;www.lydsy.com:808&#x2F;JudgeOnline&#x2F;problem.php?id=3669&quot;&gt;传送门：NOI2014 魔法森林&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Python Tips</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/python-tips/</link>
            <guid>https://twistoy.com/posts/python-tips/</guid>
            <description>&lt;h3 id=&quot;switch-casede-xie-fa&quot;&gt;switch...case的写法&lt;&#x2F;h3&gt;
&lt;p&gt;可以用if...elif...else的办法，或者使用跳转表：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    {
        0: &amp;quot;zero&amp;quot;,
        1: &amp;quot;one&amp;quot;,
        2: &amp;quot;two&amp;quot;
    }.get(x, &amp;quot;error&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;you-guan-yu-chang-liang&quot;&gt;有关于常量&lt;&#x2F;h3&gt;
&lt;p&gt;显然命名风格这种办法并不能根本上阻止常量被改变。那么就可以定义一个类，修改这个类的&lt;code&gt;__setattr__&lt;&#x2F;code&gt;方法，当检查到key已经存在的时候直接抛出一个异常就可以了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-yong-withzi-dong-guan-bi-zi-yuan&quot;&gt;使用with自动关闭资源&lt;&#x2F;h3&gt;
&lt;p&gt;with语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有with语句的代码块的执行过程：&lt;br &#x2F;&gt;
1. 计算表达式的值，返回一个上下文管理器对象。&lt;br &#x2F;&gt;
2. 加载上下文管理器对象的&lt;code&gt;__exit__()&lt;&#x2F;code&gt;方法以备后用。&lt;br &#x2F;&gt;
3. 调用上下文管理器对象的&lt;code&gt;__enter__()&lt;&#x2F;code&gt;方法。&lt;br &#x2F;&gt;
4. 如果with语句中设置了目标对象，则将&lt;code&gt;__enter__()&lt;&#x2F;code&gt;方法的返回值赋值给目标对象。&lt;br &#x2F;&gt;
5. 执行with中的代码块。&lt;br &#x2F;&gt;
6. 如果步骤5中的代码正常结束，调用上下文管理器对象的&lt;code&gt;__exit__()&lt;&#x2F;code&gt;方法，其返回值直接忽略。&lt;br &#x2F;&gt;
7. 如果步骤5中的代码执行过程中发生异常，调用上下文管理器对象的&lt;code&gt;__exit__()&lt;&#x2F;code&gt;方法，并将异常类型、值以及trackback信息作为参数传递给&lt;code&gt;__exit__()&lt;&#x2F;code&gt;方法。如果&lt;code&gt;__exit__()&lt;&#x2F;code&gt;返回值为&lt;code&gt;false&lt;&#x2F;code&gt;，则异常会被重新抛出；如果其返回值为&lt;code&gt;true&lt;&#x2F;code&gt;，异常被挂起，程序继续执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bi-mian-finallyzhong-ke-neng-fa-sheng-de-xian-jing&quot;&gt;避免finally中可能发生的陷阱&lt;&#x2F;h3&gt;
&lt;p&gt;小心由于finally中的return和break，导致被临时保存的应该向上层抛出的异常的屏蔽。&lt;br &#x2F;&gt;
finally会在其他部分的return之前被执行，也就是说其他部分中return的值会被保存起来，先去执行finally中的代码。如果finally中有return的话，会导致很奇怪严重的错误。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pan-duan-dui-xiang-shi-fou-wei-kong&quot;&gt;判断对象是否为空&lt;&#x2F;h3&gt;
&lt;p&gt;Python中以下数据会当作空来处理：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;常量None。&lt;&#x2F;li&gt;
&lt;li&gt;常量False。&lt;&#x2F;li&gt;
&lt;li&gt;任何形式的数值类型零，如：0、0L，0.0，0j。&lt;&#x2F;li&gt;
&lt;li&gt;空的序列，如：&amp;quot;&amp;quot;、()、[]。&lt;&#x2F;li&gt;
&lt;li&gt;空的字典，如：{}。&lt;&#x2F;li&gt;
&lt;li&gt;当用户定义的类中定义了nonzero()方法和len()方法，并且该方法返回整数0或者布尔值False的时候。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Python会首先调用&lt;code&gt;__nonzero__()&lt;&#x2F;code&gt;方法来判断返回值为True或False。如果没定义这个方法，则会调用&lt;code&gt;__len__()&lt;&#x2F;code&gt;方法判断返回值是否为0。如果都没有，那么该类的实例在用布尔测试的时候都为真。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lian-jie-zi-fu-chuan-ying-you-xian-shi-yong-joiner-bu-shi&quot;&gt;连接字符串应优先使用join而不是+&lt;&#x2F;h3&gt;
&lt;p&gt;这里join比+的效率要高上很多。这里是由于join会先遍历整个list中的所有字符串，把他们的长度加起来，只进行一次内存申请，这里所有的字符串只会被拷贝一次；而运算符+则是每进行一个运算都要申请一次内存，并且进行一次内存拷贝，这样n个字符串连接就要进行n-1次内存申请。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sort-he-sorted&quot;&gt;sort()和sorted()&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    sorted(iterable[, cmp[, key[, reserse]]])
    a.sort([cmp[, key[, reserse]]])
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;sort会直接修改原有列表，sorted会返回一个排序后的对象。&lt;&#x2F;li&gt;
&lt;li&gt;传入key比传入cmp的效率高，大约快50%。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;shi-yong-tracebackhuo-qu-zhan-xin-xi&quot;&gt;使用traceback获取栈信息&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;    traceback.print_exc()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-yong-mo-kuai-shi-xian-dan-li-mo-shi&quot;&gt;使用模块实现单例模式&lt;&#x2F;h3&gt;
&lt;p&gt;在python中，模块是可以保证只初始化一次，线程安全，模块内变量绑定在模块中。完美的符合了单例模式的要求。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;li-yong-mixinte-xing-rang-cheng-xu-geng-ling-huo&quot;&gt;利用mixin特性让程序更灵活&lt;&#x2F;h3&gt;
&lt;p&gt;利用了Python的mixin特性。在运行时可以改变一个实例的基类。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    #demo
    import mixins
    def staff():
        people = People()
        bases = [getattr(minxins, i) for i in config.checked()]
        people.__bases__ += tuple(bases)
        return people
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>模板实例化对成员函数的要求</title>
            <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/template-instantiation/</link>
            <guid>https://twistoy.com/posts/template-instantiation/</guid>
            <description>&lt;h1 id=&quot;wen-ti-de-bei-jing&quot;&gt;问题的背景&lt;&#x2F;h1&gt;
&lt;p&gt;假如想写一个类模板C，能够实例化此模板的类型必须具有一个名为&lt;code&gt;Clone()&lt;&#x2F;code&gt;的&lt;code&gt;const&lt;&#x2F;code&gt;成员函数，此函数不带参数，返回值为指针，指向同类型的对象。&lt;br &#x2F;&gt;
就像这样：&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
class C
{
    &amp;#x2F;&amp;#x2F; ...
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;si-kao-de-guo-cheng&quot;&gt;思考的过程&lt;&#x2F;h1&gt;
&lt;p&gt;我们可以在模板C中写一段代码，让它去调用函数&lt;code&gt;Clone()&lt;&#x2F;code&gt;，那么如果实例化的类型T没有这个函数的话，就不能通过编译。可是在模板类中只有被使用到的函数才会被实例化，所以我们只能去考虑一定会被实例化的函数。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;&#x2F;li&gt;
&lt;li&gt;析构函数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们首先就会考虑到这两个函数，然后再考虑一下，一个类可能有很多个构造函数，但是一定只会有一个析构函数，所以写在析构函数里会更划算一些。&lt;&#x2F;p&gt;
&lt;p&gt;首先就会写出这样的代码来：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
class C
{
pulibc:
    ~C()
    {
        &amp;#x2F;&amp;#x2F; ...
        T t;
        t.Clone();
        &amp;#x2F;&amp;#x2F; ...
    }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是这样的实现会造成一定程度的浪费，因为不但构造了一个T的实体，还要调用T的默认构造函数，最后还要析构一次。&lt;br &#x2F;&gt;
经过仔细的思考之后我们发现，其实我们并不需要真的去调用这个函数，只要对这样的函数提出一个要求就可以了。就会发现了下面这段更好的代码。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;template&amp;lt;typename T&amp;gt;
class C
{
pulibc:
    ~C()
    {
        &amp;#x2F;&amp;#x2F; ...

        T* (T::*test) () const = &amp;amp;T::Clone;
        test;

        &amp;#x2F;&amp;#x2F; ...
    }
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这里只是对这样的一个函数提出的一个需求的要求，并没有实例化这个类型。&lt;&#x2F;p&gt;
&lt;p&gt;这样做的好处同时还有，会有一个漂亮很多的很明显的报错。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>2015多校Contest 5. 1003. Hotaru&#x27;s problem</title>
            <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/2015-duoxiao-contest5-1003/</link>
            <guid>https://twistoy.com/posts/2015-duoxiao-contest5-1003/</guid>
            <description>&lt;h3 id=&quot;ti-mu-da-yi&quot;&gt;题目大意&lt;&#x2F;h3&gt;
&lt;p&gt;一个N-sequence由三个部分组成，并符合：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;第一部分和第三部分相同。&lt;&#x2F;li&gt;
&lt;li&gt;第一部分和第二部分回文。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;求最长的N-sequence的长度。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h3 id=&quot;fen-xi&quot;&gt;分析&lt;&#x2F;h3&gt;
&lt;p&gt;N-sequence的特征是第一部分和第三部分相同，并且第一部分和第二部分回文。那么条件可以转化成：&lt;strong&gt;第一部分&lt;&#x2F;strong&gt;和&lt;strong&gt;第二部分&lt;&#x2F;strong&gt; &lt;em&gt;回文&lt;&#x2F;em&gt;，并且&lt;strong&gt;第二部分&lt;&#x2F;strong&gt;和&lt;strong&gt;第三部分&lt;&#x2F;strong&gt; &lt;em&gt;回文&lt;&#x2F;em&gt;。那么问题就转化成了：两个回文串的重合问题。&lt;&#x2F;p&gt;
&lt;p&gt;先用manacher求出任意一个位置作中心的最长回文串的长度。因为第一部分和第二部分组成的回文串&lt;code&gt;s1&lt;&#x2F;code&gt;一定是一个偶数长度的串，所以一定是我们添加的&lt;code&gt;#&lt;&#x2F;code&gt;位置。每个中间位置&lt;code&gt;i&lt;&#x2F;code&gt;可以覆盖左边的&lt;code&gt;i-rad[i]&lt;&#x2F;code&gt;到右边的&lt;code&gt;i+rad[i]&lt;&#x2F;code&gt;的范围。我们存下来能覆盖的最大右侧，这样我们在枚举每一个第二个端点的时候，去找到第一个端点。&lt;&#x2F;p&gt;
&lt;p&gt;在枚举到每个端点2的时候，我们可以算出来最大合法的端点1的位置，就是：&lt;code&gt;i-rad[i]&lt;&#x2F;code&gt;。那么我们就要找一个在合法范围内的最小的做端点。显然可以存下来当前所有右侧合法的端点，然后二分查找。然后就结束了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h3&gt;
&lt;p&gt;比赛的时候蠢在了好几个不一样的地方。真是…&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

const int maxn = 200100;
vector&amp;lt;int&amp;gt; a;
int rad[maxn];
vector&amp;lt;int&amp;gt; del[maxn];
set&amp;lt;int&amp;gt; fuck;

void manacher() {
    memset(rad, 0, sizeof(rad));
    int n = a.size();
    int i,j,k;
    i=0;
    j=1;
    while(i&amp;lt;n)
    {
        while(i-j&amp;gt;=0 &amp;amp;&amp;amp; i+j&amp;lt;n &amp;amp;&amp;amp; a[i-j]==a[i+j])
            j++;
        rad[i]=j-1;
        k=1;
        while(k&amp;lt;=rad[i] &amp;amp;&amp;amp; rad[i]-k!=rad[i-k])
        {
            rad[i+k]=min(rad[i-k],rad[i]-k);
            k++;
        }
        i += k;
        j = max(j-k,0);
    }
}

int main() {
    int T;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
    for (int cas = 1; cas &amp;lt;= T; cas++) {
        int n;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
        a.clear();

        for (int i = 0; i &amp;lt; n; i++) {
            int x;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;x);
            a.push_back(-1);
            a.push_back(x);
        }
        a.push_back(-1);

        manacher();
    &amp;#x2F;&amp;#x2F;    for (int i = 0; i &amp;lt; a.size(); i++) {
    &amp;#x2F;&amp;#x2F;        printf(&amp;quot;%2d &amp;quot;, i);
    &amp;#x2F;&amp;#x2F;    }puts(&amp;quot;&amp;quot;);
    &amp;#x2F;&amp;#x2F;    for (int i = 0; i &amp;lt; a.size(); i++) {
    &amp;#x2F;&amp;#x2F;        printf(&amp;quot;%2d &amp;quot;, a[i]);
    &amp;#x2F;&amp;#x2F;    }puts(&amp;quot;&amp;quot;);
    &amp;#x2F;&amp;#x2F;    for (int i = 0; i &amp;lt; a.size(); i++) {
    &amp;#x2F;&amp;#x2F;        printf(&amp;quot;%2d &amp;quot;, rad[i]);
    &amp;#x2F;&amp;#x2F;    }puts(&amp;quot;&amp;quot;);
        int len = a.size();

        for (int i = 0; i &amp;lt; len; i++) {
            del[i].clear();
        }

        for (int i = 0; i &amp;lt; len; i++) {
            if (a[i] == -1) {
                if (i+rad[i] &amp;lt; len) {
                    del[i+rad[i]].push_back(i);
    &amp;#x2F;&amp;#x2F;                printf(&amp;quot;del %d at %d\n&amp;quot;, i, i+rad[i]);
                }
            }
        }

        int ans = 0;
        fuck.clear();
        for (int i = 0; i &amp;lt; len; i++) {
            if (a[i] != -1) continue;

            set&amp;lt;int&amp;gt;::iterator iter = fuck.lower_bound(i-rad[i]);
            if (iter != fuck.end()) {
    &amp;#x2F;&amp;#x2F;            printf(&amp;quot;find %d at %d\n&amp;quot;, *iter, i);
                ans = max(ans, (i-*iter) &amp;#x2F; 2);
            }

            fuck.insert(i);
            for (int j = 0; j &amp;lt; (int) del[i].size(); j++) {
                fuck.erase(del[i][j]);
            }
        }
        printf(&amp;quot;Case #%d: %d\n&amp;quot;, cas, ans * 3);
    }
    return 0;
}

&amp;#x2F;*
idx:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
raw: -1  2 -1  3 -1  4 -1  4 -1  3 -1  2 -1  2 -1  3 -1  4 -1  4 -1
rad:  0  1  0  1  0  1  6  1  0  1  0  1  8  1  0  1  0  1  2  1  0
*&amp;#x2F;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>Operator new 的重载</title>
            <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/override-operator-new/</link>
            <guid>https://twistoy.com/posts/override-operator-new/</guid>
            <description>&lt;p&gt;new作为关键字是不能被重载的。当new作为关键字的时候的行为是：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;调用operator new分配内存。&lt;&#x2F;li&gt;
&lt;li&gt;调用构造函数生成对象。&lt;&#x2F;li&gt;
&lt;li&gt;返回相应的指针。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;new的行为是不能被改变的，但是这里的operator new的行为是可以改变的。也就是对operator new的重载。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;new-yun-suan-fu-biao-da-shi-de-zhong-zai&quot;&gt;new 运算符表达式的重载&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;operator new&lt;&#x2F;strong&gt;操作符可以被每个类作为成员函数重载，也可以作为全局函数重载。这里应该是推荐作为成员函数重载的。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;void-operator-new-size-t-size-throw-std-bad-alloc&quot;&gt;&lt;em&gt;&lt;em&gt;void&lt;&#x2F;em&gt; operator new(size_t size) throw(std::bad_alloc);&lt;&#x2F;em&gt;*&lt;&#x2F;h5&gt;
&lt;p&gt;参数是一个&lt;code&gt;size_t&lt;&#x2F;code&gt;类型，指明了要分配的内存的大小。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    void* operator new(std::size_t) throw(std::bad_alloc);
    void* operator delete(std::size_t) throw();
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果在构造函数执行的时候发生异常，在栈展开的过程中，要回收在第一步中&lt;strong&gt;operator new&lt;&#x2F;strong&gt;分配的内存的时候，会调用想对应的&lt;strong&gt;operator delete&lt;&#x2F;strong&gt;函数。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;void-operator-new-size-t-size-throw-std-bad-alloc-1&quot;&gt;&lt;em&gt;&lt;em&gt;void&lt;&#x2F;em&gt; operator new[](size_t size) throw(std::bad_alloc);&lt;&#x2F;em&gt;*&lt;&#x2F;h5&gt;
&lt;p&gt;用于分配数组对象内存的new操作符。如果数组的基类型没有这个成员函数的话，会调用全局的版本分配内存。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    void * operator new[] (std::size_t) throw(std::bad_alloc);
    void operator delete[](void*) throw();
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;void-operator-new-size-t-void&quot;&gt;&lt;em&gt;&lt;em&gt;void&lt;&#x2F;em&gt; operator new(size_t,void&lt;&#x2F;em&gt;)**&lt;&#x2F;h5&gt;
&lt;p&gt;带位置的new操作符（placement new）重载版本。C++标准库中已经提供了这个版本的简单实现，只是简单的返回参数指定的地址。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;#x2F;&amp;#x2F; Default placement versions of operator new.
    inline void* operator new(std::size_t, void* __p) throw() { return __p; }
    inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
    
    &amp;#x2F;&amp;#x2F; Default placement versions of operator delete.
    inline void  operator delete  (void*, void*) throw() { }
    inline void  operator delete[](void*, void*) throw() { }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;zi-xing-ding-zhi-can-shu-de-operator-newhan-shu&quot;&gt;自行定制参数的operator new函数&lt;&#x2F;h5&gt;
&lt;pre&gt;&lt;code&gt;    operator new(size_,Type1, Type2, ... );
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这时候就可以自定义参数以及其行为。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    struct point {
        int x, y;
        point() = default;
        point(int x, int y) : x(x), y(y) {}
        void* operator new(size_t, int&amp;amp;cur);
    } _pool[maxn];
    int cur;
    
    void* point::operator new(size_t sz, int &amp;amp;cur) {
        return _pool+(cur++);
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;reference:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;zh&#x2F;New_(C%2B%2B)&quot;&gt;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;zh&#x2F;New_(C%2B%2B&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</description>
        </item>
        <item>
            <title>主席树</title>
            <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/president-tree-learning/</link>
            <guid>https://twistoy.com/posts/president-tree-learning/</guid>
            <description>&lt;p&gt;主席树我的理解是可持久化线段树的一种应用吧。本质上就是可持久化线段树，不过我们在查询的时候用到了他们之间可以相减的性质。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;首先介绍一下可持久化线段树。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ke-chi-jiu-hua-xian-duan-shu&quot;&gt;可持久化线段树&lt;&#x2F;h3&gt;
&lt;p&gt;可持久化线段树是可持久化数据结构中的一种，主席树的实现就是利用了可持久化线段树的。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ke-chi-jiu-hua-shu-ju-jie-gou&quot;&gt;可持久化数据结构&lt;&#x2F;h4&gt;
&lt;p&gt;所谓的可持久化数据结构，就是保存这个数据结构的历史版本，同时应该公用他们的公有部分来减少内存上的消耗。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ke-chi-jiu-hua-xian-duan-shu-1&quot;&gt;可持久化线段树&lt;&#x2F;h4&gt;
&lt;p&gt;在每次更新的时候，我们保存下来每次更新的历史版本，以便我们之后查阅。在主席树中我们用到的线段树是保存当前范围内位置有多少个数的。以下都用这个当例子。&lt;&#x2F;p&gt;
&lt;p&gt;下面图中点的表示：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;pt-node.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h5 id=&quot;jian-shu&quot;&gt;建树&lt;&#x2F;h5&gt;
&lt;p&gt;建立一颗空树，这里只要递归的建立就可以了。和普通的线段树是一样的。&lt;code&gt;build(1, 5)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;pt-1.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h5 id=&quot;geng-xin&quot;&gt;更新&lt;&#x2F;h5&gt;
&lt;p&gt;我们这里的更新操作是不改变原有的点，对于所有的修改我们都会建立新的点出来。&lt;br &#x2F;&gt;
&lt;code&gt;insert(root, 1, 5, 3)&lt;&#x2F;code&gt;：在3位置插入了一个值。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;pt-2.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;insert(root, 1, 5, 4)&lt;&#x2F;code&gt;：在4位置插入了一个值。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;7vijdo.com1.z0.glb.clouddn.com&#x2F;pt-3.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我们可以看到，在修改线段树上维护的数据的时候我们都没有改变原本的点，只是建立了一个新点出来。这样我们可以放心的复用以前的点（因为他们根本就没有变过），这样来达到节省空间的目的。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;cha-xun&quot;&gt;查询&lt;&#x2F;h5&gt;
&lt;p&gt;查询的方法和普通的线段树一样，还是根据所查信息来决定是走左孩子还有右孩子就可以了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-xi-shu&quot;&gt;主席树&lt;&#x2F;h3&gt;
&lt;p&gt;主席树中我们处理任意区间第K大的方法，有点像在处理任意区间和的时候我们用的求好前缀和再相减的过程。这里我们在查询的时候就是把两个线段树相减。&lt;br &#x2F;&gt;
如果查询区间(s, t)的第K大，我们首先可以找到他们两个所对应的数字插入的时候的线段树，（我们把数组里的元素按顺序插入，并且把插入后的根保存起来。因为这些根一定都是不同的，假定我们保存在了数组T中。即当前的查询可以表示为：&lt;code&gt;query(s, t, ln, rn, k)&lt;&#x2F;code&gt;）&lt;br &#x2F;&gt;
那么如果\(T[t].left.data - T[s-1].left.data &amp;lt;= k\)，就证明了这个第K小的数应该在左边。我们递归的处理 &lt;code&gt;query(s.left, t.left, ln, mid, k)&lt;&#x2F;code&gt;，否则第K小的数就应该在右边，我们递归处理&lt;code&gt;query(s.right, t.right, mid+1, rn, k-(t.left.data-s.left.data))&lt;&#x2F;code&gt;（注意更新右侧不是第K小，应该减去左侧数字的个数。）&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dai-ma-shi-xian-he-li-ti&quot;&gt;代码实现和例题&lt;&#x2F;h4&gt;
&lt;p&gt;例题&lt;a href=&quot;http:&#x2F;&#x2F;poj.org&#x2F;problem?id=2104&quot;&gt;poj2104&lt;&#x2F;a&gt; 代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;iostream&amp;gt;
    #include &amp;lt;cstdio&amp;gt;
    #include &amp;lt;algorithm&amp;gt;
    #include &amp;lt;vector&amp;gt;
    using namespace std;  
    const int maxn = 1000100;
    
    struct node {  
        node *ls, *rs;
        int data;
    } _pool[maxn * 20], *current;
    
    
    void init() {  
        current = _pool;
    }
    
    node* allocNode() {  
        return current++;
    }
    
    node* build(int ln, int rn) {  
        node* now = allocNode();
        now-&amp;gt;data = 0;
        now-&amp;gt;ls = NULL;
        now-&amp;gt;rs = NULL;
        if (ln &amp;lt; rn) {
            int mid = (ln + rn) &amp;#x2F; 2;
            now-&amp;gt;ls = build(ln, mid);
            now-&amp;gt;rs = build(mid + 1, rn);
        }
        return now;
    }
    
    node* insert(node* root, int ln, int rn, int val) {  
        node* now = allocNode();
        *now = *root;
        now-&amp;gt;data++;
        if (ln != rn) {
            int mid = (ln + rn) &amp;#x2F; 2;
            if (val &amp;lt;= mid) {
                now-&amp;gt;ls= insert(now-&amp;gt;ls, ln, mid, val);
            }
            else {
                now-&amp;gt;rs= insert(now-&amp;gt;rs, mid+1, rn, val);
            }
        }
        return now;
    }
    
    int query(node* s, node* t, int ln, int rn, int k) {  
        &amp;#x2F;&amp;#x2F;printf(&amp;quot;&amp;gt;&amp;gt;&amp;gt; [%d, %d], (%d, %d), %d\n&amp;quot;, s-_pool, t-_pool, ln, rn, k);
        &amp;#x2F;&amp;#x2F;printf(&amp;quot;--- &amp;lt;%d, %d&amp;gt;, &amp;lt;%d, %d&amp;gt;\n&amp;quot;, s-&amp;gt;ls-_pool, s-&amp;gt;rs-_pool, t-&amp;gt;ls-_pool, t-&amp;gt;rs-_pool);
        if (ln == rn) return ln;
        int delta = t-&amp;gt;ls-&amp;gt;data - s-&amp;gt;ls-&amp;gt;data;
        int mid = (ln + rn) &amp;#x2F; 2;
        if (delta &amp;gt;= k) {
            return query(s-&amp;gt;ls, t-&amp;gt;ls, ln, mid, k);
        }
        else {
            return query(s-&amp;gt;rs, t-&amp;gt;rs, mid+1, rn, k - delta);
        }
    }
    
    void treeShow(node* root) {  
        if (root != NULL) {
            printf(&amp;quot;%d: &amp;lt;(%d, %d), %d&amp;gt;\n&amp;quot;, root-_pool, root-&amp;gt;ls-_pool, root-&amp;gt;rs-_pool, root-&amp;gt;data);
            treeShow(root-&amp;gt;ls);
            treeShow(root-&amp;gt;rs);
        }
    }
    
    node* T[maxn];  
    int ori[maxn];  
    int dis[maxn];  
    int main() {  
        int n, q;
        while (scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;q) != EOF) {
            init();
            for (int i = 1; i &amp;lt;= n; i++) {
                scanf(&amp;quot;%d&amp;quot;, &amp;amp;ori[i]);
                dis[i] = ori[i];
            }
            sort(dis + 1, dis + n + 1);
            int m = unique(dis + 1, dis + 1 + n) - dis - 1;
            T[0] = build(1, m);
    
            for (int i = 1; i &amp;lt;= n; i++) {
                int pos = lower_bound(dis + 1, dis + m + 1, ori[i]) - dis;
                T[i] = insert(T[i-1], 1, m, pos);
            }
            &amp;#x2F;&amp;#x2F;treeShow(T[2]);
    
            for (int i = 0; i &amp;lt; q; i++) {
                int s, t, k;
                scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;s, &amp;amp;t, &amp;amp;k);
                printf(&amp;quot;%d\n&amp;quot;, dis[query(T[s-1], T[t], 1, m, k)]);
            }
        }
        return 0;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>UVALive 5848. Soju</title>
            <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/uvalive-5848/</link>
            <guid>https://twistoy.com/posts/uvalive-5848/</guid>
            <description>&lt;h1 id=&quot;ti-mu-da-yi&quot;&gt;题目大意&lt;&#x2F;h1&gt;
&lt;p&gt;给定两个平面上的点集，求两个点集中距离最近的两个点的距离。（这里的距离说的是曼哈顿距离。）题目中保证了左边点集的点都一定在右侧的点集的左侧。也就是任意一个在左侧集合的点的横坐标都小于任意一个在右侧集合的点。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;fen-xi&quot;&gt;分析&lt;&#x2F;h2&gt;
&lt;p&gt;题目中反复的提示了左侧的点一定在左侧。那么来分析曼哈顿距离的式子：
[|x_1-x_2|+|y_1-x_2|]
其中令(x_1, y_1)是处于左侧的点的话，其中的第一项一定是小于0的，可以去掉绝对值符号。那么我们如果令我们枚举的右侧点在左侧点的下面的话，右侧的绝对值就也可以去掉了。那么式子就可以变成如下的形式：
[(y_1-x_1)-(y_2-x_2)]那么这个时候只要维护后一项的值最大就好了。对于右侧点再上方的情况，类似处理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma&quot;&gt;代码&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#include &amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;
using namespace std;
const int maxn = 100100;
const int inf = INT_MAX;

struct point {
    int x, y;
    point() {}
    point(int x, int y) : x(x), y(y) {}
    void input() {
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;y);
    }
} a[maxn], b[maxn];

bool operator &amp;lt; (const point&amp;amp; a, const point&amp;amp; b) {
    return a.y &amp;lt; b.y;
}

int main() {
    int T;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
    while (T--) {
        int n;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
        for (int i = 0; i &amp;lt; n; i++) {
            a[i].input();
        }
        int m;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;m);
        for (int i = 0; i &amp;lt; m; i++) {
            b[i].input();
        }
        sort(a, a+n);
        sort(b, b+m);

        int ans = inf;

        for (int i = 0, j = 0, tmp = -inf; i &amp;lt; n; i++) {
            for (; j &amp;lt; m; j++) {
                if (a[i].y &amp;lt; b[j].y) {
                    break;
                }
                tmp = max(tmp, b[j].y - b[j].x);
            }
            ans = min(ans, a[i].y - a[i].x - tmp);
        }

        reverse(a, a+n);
        reverse(b, b+m);

        for (int i = 0, j = 0, tmp = inf; i &amp;lt; n; i++) {
            for (; j &amp;lt; m; j++) {
                if (a[i].y &amp;gt; b[j].y) {
                    break;
                }
                tmp = min(tmp, b[j].y + b[j].x);
            }
            ans = min(ans, tmp - a[i].x - a[i].y);
        }

        printf(&amp;quot;%d\n&amp;quot;, ans);
    }
    return 0;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>Python 装饰器</title>
            <pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate>
            <link>https://twistoy.com/posts/python-decorator/</link>
            <guid>https://twistoy.com/posts/python-decorator/</guid>
            <description>&lt;p&gt;给函数添加一个包装层以添加额外的处理部分，我们就可以使用装饰器这种方法。&lt;&#x2F;p&gt;
&lt;h6 id=&quot;ding-yi-yi-ge-zhuang-shi-qi&quot;&gt;定义一个装饰器：&lt;&#x2F;h6&gt;
&lt;pre&gt;&lt;code&gt;    import time
    
    def timethis(func):
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(func.__name__, end - start)
            return result
        return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;shi-yong-zhe-ge-zhuang-shi-qi&quot;&gt;使用这个装饰器&lt;&#x2F;h6&gt;
&lt;pre&gt;&lt;code&gt;    @timethis
    def countdown(n):
        while n &amp;gt; 0:
            n -= 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当如此编写代码的时候和单独这么写的效果是一样的：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    def countdown(n):
        while n &amp;gt; 0:
            n -= 1
    countdown = timethis(countdown)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;bao-cun-han-shu-qian-ming-deng-xin-xi&quot;&gt;保存函数签名等信息&lt;&#x2F;h6&gt;
&lt;p&gt;但是我们像上面那么做的时候，其实是丢失了函数签名，doc等信息的，这时候可以通过对装饰器的装饰来解决这个问题。改动一下上面的代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    import time
    from functools import wraps
    
    def timethis(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(func.__name__, end - start)
            return result
        return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;dui-zhuang-shi-qi-jin-xing-jie-bao-zhuang&quot;&gt;对装饰器进行解包装&lt;&#x2F;h6&gt;
&lt;p&gt;可以通过访问&lt;code&gt;__wrapped__&lt;&#x2F;code&gt;属性来实现对原始函数的访问。&lt;&#x2F;p&gt;
&lt;h6 id=&quot;yi-ge-ke-yi-jie-shou-can-shu-de-zhuang-shi-qi&quot;&gt;一个可以接受参数的装饰器&lt;&#x2F;h6&gt;
&lt;p&gt;其实是很简单的，在外层的函数部分接受定义装饰器时的参数就可以了。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    from functools import wraps, partial
    import logging
    
    def logged(level, name=None, message=None):
        def decorator(func):
            logname = name if name else func.__module__
            log = logging.getLogger(logname)
            logmsg = message if message else func.__name__
    
            @wraps(func)
            def wrapper(*args, **kwargs):
                log.log(level, logmsg)
                return func(*args, **kwargs)
    
            return wrapper
    
        return decorator
    
    
    @logged(logging.DEBUG)
    def add(x, y):
        return x + y
    
    logging.basicConfig(level=logging.DEBUG)
    print(add(2, 3))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;zhuang-shi-qi-can-shu-xu-yao-ke-yi-xiu-gai&quot;&gt;装饰器参数需要可以修改&lt;&#x2F;h6&gt;
&lt;p&gt;还是刚才的那段代码，这次用到了另一个装饰器并且使用了&lt;code&gt;nonlocal&lt;&#x2F;code&gt;关键字来声明装饰器内部的属性。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    from functools import wraps, partial
    import logging
    
    def attach_wrapper(obj, func=None):
        if func is None:
            return partial(attach_wrapper, obj)
        setattr(obj, func.__name__, func)
        return func
    
    def logged(level, name=None, message=None):
        def decorator(func):
            logname = name if name else func.__module__
            log = logging.getLogger(logname)
            logmsg = message if message else func.__name__
    
            @wraps(func)
            def wrapper(*args, **kwargs):
                log.log(level, logmsg)
                return func(*args, **kwargs)
    
            @attach_wrapper(wrapper)
            def set_level(newlevel):
                nonlocal level
                level = newlevel
    
            @attach_wrapper(wrapper)
            def set_message(newmsg):
                nonlocal logmsg
                logmsg = newmsg
    
            return wrapper
    
        return decorator
    
    
    @logged(logging.DEBUG)
    def add(x, y):
        return x + y
    
    logging.basicConfig(level=logging.DEBUG)
    print(add(2, 3))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;ke-xuan-can-shu-de-zhuang-shi-qi&quot;&gt;可选参数的装饰器&lt;&#x2F;h6&gt;
&lt;p&gt;还是上面的那段代码，如果&lt;code&gt;level&lt;&#x2F;code&gt;属性也是可选的，像上面那么写我们就必须用这样的方式去使用它：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    @logged()
    def fuck():
        pass
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是显然这不是我所希望的，因为我们总会忘记那个空的括号。所以我们就可以改动一下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    def logged(func=None, *, level=logging.DEBUG, name=None, message=None):
        if func is None:
            return partial(logged, level=level, name=name, message=message)
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__
    
        @wraps(func)
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)
        return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;副作用是&lt;code&gt;*&lt;&#x2F;code&gt;之后的参数必须显式的给出形参的名字。&lt;&#x2F;p&gt;
&lt;h6 id=&quot;yong-lei-lai-shi-xian-zhuang-shi-qi&quot;&gt;用类来实现装饰器&lt;&#x2F;h6&gt;
&lt;p&gt;前面给出的都是用函数闭包来实现装饰器的例子，当然我们也可以用一个类来实现装饰器。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    from functools import wraps
    
    class A:
        def decorator1(self, func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                print(&amp;quot;Decorate 1&amp;quot;)
                return func(*args, **kwargs)
            return wrapper
    
        @classmethod
        def decorator2(cls, func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                print (&amp;#x27;Decorator 2&amp;#x27;)
                return func(*args, **kwargs)
            return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;ba-zhuang-shi-qi-ding-yi-cheng-lei&quot;&gt;把装饰器定义成类&lt;&#x2F;h6&gt;
&lt;p&gt;这个时候要实现类的&lt;code&gt;__call__&lt;&#x2F;code&gt;和&lt;code&gt;__get__&lt;&#x2F;code&gt;方法。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    class Profield:
        def __init__(self, func):
            wraps(func)(self)
            self.ncalls = 0
    
        def __call__(self, *args, **kwargs):
            self.ncalls += 1
            return self.__wrapped__(*args, **kwargs)
    
        def __get__(self, instance, cls):
            if instance is None:
                return self
            else:
                return types.MethodType(self, instance)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的&lt;code&gt;__get__&lt;&#x2F;code&gt;方法的实现一定不能忽略。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;相关资料：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3.4&#x2F;library&#x2F;functools.html&quot;&gt;functools — Higher-order functions and operations on callable objects&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h6 id=&quot;li-yong-zhuang-shi-qi-gei-bei-bao-zhuang-de-han-shu-tian-jia-can-shu&quot;&gt;利用装饰器给被包装的函数添加参数&lt;&#x2F;h6&gt;
&lt;pre&gt;&lt;code&gt;    import inspect
    
    def optional_debug(func):
        if &amp;#x27;debug&amp;#x27; in inspect.getargspec(func).args:
            raise TypeError(&amp;#x27;debug argument already defined.&amp;#x27;)
        @wraps(func)
        def wrapper(*args, debug=False, **kwargs):
            if debug:
                print(&amp;quot;fuck debug&amp;quot;, func.__name__)
            return func(*args, **kwargs)
        return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的实现还检查了被包装的函数是不是已经有要包装进去的参数了来保证不会有参数名字冲突的问题。 但是这种实现不能解决函数签名的问题，在函数签名中是没有我们加入的debug这个参数的。所以我们再次修改我们的实现。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;    def optional_debug(func):
        if &amp;#x27;debug&amp;#x27; in inspect.getargspec(func).args:
            raise TypeError(&amp;#x27;debug argument already defined.&amp;#x27;)
        @wraps(func)
        def wrapper(*args, debug=False, **kwargs):
            if debug:
                print(&amp;quot;fuck debug&amp;quot;, func.__name__)
            return func(*args, **kwargs)
    
        sig = inspect.signature(func)
        parms = list(sig, parameters.values())
        parms.append(inspect.Parameter(&amp;#x27;debug&amp;#x27;, inspect.Parameter.KEYWORD_ONLY, default=False))
        wrapper.__signature__ = sig.replace(parameters=parms)
    
        return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h6 id=&quot;li-yong-zhuang-shi-qi-gai-bian-lei-fang-fa-de-xing-wei&quot;&gt;利用装饰器改变类方法的行为&lt;&#x2F;h6&gt;
&lt;pre&gt;&lt;code&gt;    def log_getattribute(cls):
        orig_getattribute = cls.__getattribute__
    
        def new_attribute(self, name):
            print(&amp;#x27;getting:&amp;#x27;, name)
            return orig_getattribute(self, name)
    
        cls.__getattribute__ = new_attribute
    
    @log_getattribute
    class A:
        def __init__(self, x):
            self.x = x
        def spam(self):
            pass
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
    </channel>
</rss>
